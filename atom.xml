<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>麦 田</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-14T09:51:07.047Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Maizi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原型、原型链以及继承（二）</title>
    <link href="http://yoursite.com/2017/08/14/%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%BB%A5%E5%8F%8A%E7%BB%A7%E6%89%BF%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/08/14/原型、原型链以及继承（二）/</id>
    <published>2017-08-14T02:31:59.000Z</published>
    <updated>2017-08-14T09:51:07.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对 【<em>小红书</em>】 中原型和继承进行了归纳总结。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>许多语言都支持两种继承方式：接口继承和实现继承；而 <code>JavaScript</code> 只支持 <strong>实现继承</strong>，且其主要是依靠 <strong>原型链</strong> 来实现的。</p>
<p><strong>利用原型链实现继承的主要思想：</strong><br>让一个引用类型继承另一个引用类型的属性和方法；</p>
<h4 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h4><p><strong>构造函数、原型和实例的关系：</strong><br>每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<p>如果让原型对象 <code>A Prototype</code> 等于另一个类型的实例 <code>b</code>（也即重写原型对象 <code>A Prototype</code>），则该原型对象不再包含指向对应的构造函数 <code>A</code> 的指针，而是包含了一个指向另一个原型对象 <code>B Prototype</code> 的指针；相应的，如果再让原型对象 <code>B Prototype</code> 等于另一个类型的实例 <code>c</code>，则原型对象 <code>B Prototype</code> 包含了一个指向原型对象 <code>C Prototype</code> 的指针；如此层层递进，就构成了实例与原型对象之间的链条。</p>
<p><img src="/img/2017-08-14_001.jpg" alt="原型链"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function C()&#123;&#125;</div><div class="line"></div><div class="line">function B()&#123;&#125;</div><div class="line">B.prototype = new C();    // 让 B 的原型对象等于 C 的实例</div><div class="line"></div><div class="line">function A()&#123;&#125;</div><div class="line">A.prototype = new B();    // 让 A 的原型对象等于 B 的实例</div><div class="line">var a = new A();</div></pre></td></tr></table></figure>
<p>因此，利用原型链实现继承的本质就是重写原型对象，也就是说上面例子中，原来存在于 <code>B</code> 和 <code>C</code> 的实例中的属性和方法，现在也存在于 <code>A Prototype</code> 中。</p>
<p>在通过原型链实继承的情况下，当以读取模式访问一个属性的时候，搜索过程就得以沿着原型链继续向上。</p>
<h4 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h4><p>所有引用类型默认都继承了 <code>Object</code>，而这个继承也是通过原型链实现的。所有函数的默认原型都是 <code>Object</code> 的实例，因此默认原型都会包含一个内部指针，指向 <code>Object.prototype</code>。<br><img src="/img/2017-08-14_002.jpg" alt="默认的原型"></p>
<h4 id="确定原型对象和实例的关系"><a href="#确定原型对象和实例的关系" class="headerlink" title="确定原型对象和实例的关系"></a>确定原型对象和实例的关系</h4><ul>
<li><p><code>instanceof()</code><br>只要用这个操作符来测试实例与原型链中出现过的构造函数，结果都会返回 <code>true</code>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(a instanceof C);   // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>isPrototypeOf()</code><br>只要用这个操作符来测试实例与原型链中出现过的原型对象，结果都会返回 <code>true</code>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(C.prototype.isPrototypeOf(a));    // true</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h4><ul>
<li><font color="red">给原型对象添加方法或者是重写超类型中的方法的代码一定要放在替换原型（重写原型对象）的语句之后；</font>
</li>
<li><font color="red">在通过原型链实现继承时，不能使用对象字面量创建原型方法；</font>

</li>
</ul>
<h4 id="原型链存在的问题"><a href="#原型链存在的问题" class="headerlink" title="原型链存在的问题"></a>原型链存在的问题</h4><ul>
<li><p><strong>最主要的问题来自包含引用类型值的原型</strong><br>在通过原型链实现继承时，原型对象实际上会变成另一个类型的实例；原先的实例属性（可能会有包含引用类型值的属性）也就顺理成章的变成了现在的原型属性了；而包含引用类型值的原型属性会被所有实例共享。</p>
</li>
<li><p><strong>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数</strong></p>
</li>
</ul>
<p>基于以上两点，原型链在继承中很少单独使用。</p>
<h3 id="继承的方法（六种）"><a href="#继承的方法（六种）" class="headerlink" title="继承的方法（六种）"></a>继承的方法（六种）</h3><h4 id="使用原型链（很少单独使用）"><a href="#使用原型链（很少单独使用）" class="headerlink" title="使用原型链（很少单独使用）"></a>使用原型链（很少单独使用）</h4><p>见上文 ↑</p>
<h4 id="借用构造函数（很少单独使用）"><a href="#借用构造函数（很少单独使用）" class="headerlink" title="借用构造函数（很少单独使用）"></a>借用构造函数（很少单独使用）</h4><p><strong>别名：</strong> 伪造对象或经典继承<br><strong>基本思路：</strong> 通过使用 <code>apply()</code> 和 <code>call()</code> 方法，在子类型构造函数的内部调用超类型构造函数；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType()&#123;</div><div class="line">  // 继承了 SuperType，同时还传递了参数</div><div class="line">  SuperType.call(this,&quot;Bob&quot;);</div><div class="line"></div><div class="line">  // 为避免 SuperType 构造函数不会重写子类型的属性，应该在调用超类型构造函数之后，再添加应该在子类型中定义的属性（即子类型的实例属性）</div><div class="line">  this.age = 28;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SuperType(&quot;Alice&quot;);</div><div class="line">instance1.colors.push(&quot;white&quot;);</div><div class="line">alert(instance1.colors);   // &quot;red,blue,green,white&quot;</div><div class="line">alert(instance1.name);     // Alice</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);    // &quot;red,blue,green&quot;</div><div class="line">alert(instance2.name);      // Bob</div><div class="line">alert(instance2.age);       // 28</div></pre></td></tr></table></figure></p>
<p><strong>优点：</strong> 解决了原型中包含引用类型值所带来的问题；可以在子类型构造函数中向超类型构造函数传递参数；<br><strong>缺点：</strong> 子类型只能继承超类型构造函数中的属性和方法。如果方法都在构造函数中定义，函数无法复用；如果方法在超类型中的原型中定义，则对子类型而言是不可见的；</p>
<h4 id="组合继承（最常用）"><a href="#组合继承（最常用）" class="headerlink" title="组合继承（最常用）"></a>组合继承（最常用）</h4><p><strong>别名：</strong> 伪经典继承<br><strong>基本思路：</strong> 使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function&#123;</div><div class="line">  alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name,age)&#123;</div><div class="line">  // 借用构造函数继承实例属性</div><div class="line">  SuperType.call(this,name);     // 第二次调用超类型构造函数</div><div class="line">  this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用原型链继承原型对象的属性和方法</div><div class="line">SubType.prototype = new SuperType();    // 第一次调用超类型构造函数</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">  alert(this.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance1 = new SubType(&quot;Bob&quot;,27);</div><div class="line">instance1.colors.push(&quot;white&quot;);   </div><div class="line">alert(instance1.colors);    // &quot;red,blue,green,white&quot;</div><div class="line">instance1.sayName();        // &quot;Bob&quot;</div><div class="line">instance1.sayAge();         // 27</div><div class="line"></div><div class="line">var instance2 = new SubType(&quot;Alice&quot;,29);</div><div class="line">alert(instance2.colors);    // &quot;red,blue,green&quot;</div><div class="line">instance2.sayName();        // &quot;Alice&quot;</div><div class="line">instance2.sayAge();         // 29</div></pre></td></tr></table></figure></p>
<p><strong>优点：</strong> 避免了单独使用原型链和构造函数的缺陷，融合了它们的优点；<code>instanceof</code> 和 <code>isPrototypeOf</code> 也能用于识别基于组合继承创建的对象；<br><strong>缺点：</strong> 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p><strong>基本思想：</strong> 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型；<br><strong>前提条件：</strong> 必须有一个对象可以作为另一个对象的基础；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">  name: &quot;Bob&quot;,</div><div class="line">  friends: [&quot;Ann&quot;, &quot;Lucy&quot;, &quot;Petter&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = Object.create(person,&#123;</div><div class="line">  name: &#123;</div><div class="line">    value: &quot;Alice&quot;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">person1.friens.push(&quot;David&quot;);</div><div class="line">alert(peron1.name);        // &quot;Alice&quot;</div><div class="line">alert(person1.friends);    // &quot;Ann,Lucy,Petter,David&quot;</div><div class="line"></div><div class="line">alert(person.name);        // &quot;Bob&quot;</div><div class="line">alert(person.friends);     // &quot;Ann,Lucy,Petter,David&quot;</div></pre></td></tr></table></figure></p>
<p><strong>Object.create(para1,para2)方法</strong></p>
<ul>
<li>第一个参数（必需）：一个用作新对象原型的对象；</li>
<li>第二个参数（可选）：一个为新对象定义额外属性的对象，其格式为：每个属性都是通过自己的描述符定义的。（以这种方式指定的任何属性都会覆盖原型对象上的同名属性）<br><strong>使用场景：</strong> 在没有必要创建构造函数，而只是想让一个对象与另一个对象保持类似的情况下，可以使用原型式继承；<br><strong>缺点：</strong> 包含引用类型值的属性会被所有实例所共享；</li>
</ul>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p><strong>基本思路：</strong> 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function createAnother(original)&#123;    </div><div class="line">  // 参数 original 即为将要作为新对象基础的对象</div><div class="line">  var clone = object(original);</div><div class="line">  // 添加新方法</div><div class="line">  clone.sayHi = function()&#123;</div><div class="line">    alert(&quot;Hi!&quot;);</div><div class="line">  &#125;</div><div class="line">  return clone;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> function object(o)&#123;</div><div class="line">   function F()&#123;&#125;</div><div class="line">   F.prototype = o;</div><div class="line">   return new F();</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> var person = &#123;</div><div class="line">   name: &quot;Bob&quot;,</div><div class="line">   friends: [&quot;Ann&quot;, &quot;Lucy&quot;, &quot;Petter&quot;]</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> var person1 = createAnother(person);</div><div class="line"> person1.sayHi();    // &quot;Hi!&quot;</div></pre></td></tr></table></figure></p>
<p><strong>使用场景：</strong> 在主要考虑对象而不是自定义类型和构造函数的情况下，可以使用寄生式继承；<br><strong>注意：</strong> 上面代码中使用的 <code>object()</code> 函数不是必需的，任何能返回新对象的函数都适用于此模式；</p>
<h4 id="寄生组合式继承（引用类型最理想的继承范式）"><a href="#寄生组合式继承（引用类型最理想的继承范式）" class="headerlink" title="寄生组合式继承（引用类型最理想的继承范式）"></a>寄生组合式继承（引用类型最理想的继承范式）</h4><p><strong>基本思路：</strong> 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法；（使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType,superType)&#123;</div><div class="line">  // 创建超类型原型的一个副本</div><div class="line">	var prototype = Object(superType.prototype);</div><div class="line">  // 为创建的副本添加 constructor 属性</div><div class="line">	prototype.constructor = subType;</div><div class="line">  // 将新创建的对象（副本）赋给子类型的原型</div><div class="line">	subType.prototype = prototype;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SuperType(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = function()&#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name,age)&#123;</div><div class="line">	SuperType.call(this,name);</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);    // 为子类型原型赋值</div><div class="line"></div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">	alert(this.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance = new SubType(&quot;Bob&quot;,23);</div><div class="line">instance.sayName();    // &quot;Bob&quot;</div><div class="line">instance.sayAge();     // 23</div></pre></td></tr></table></figure></p>
<p><strong>优点：</strong> 高效率（只调用了一次超类型的构造函数）；避免了在子类型原型上创建不必要的、多余的属性；原型链保持不变， <code>instanceof</code> 和 <code>isPrototypeOf</code> 能正常使用；</p>
<p>寄生组合式继承，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是对 【&lt;em&gt;小红书&lt;/em&gt;】 中原型和继承进行了归纳总结。&lt;/p&gt;
&lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;p&gt;许多语言都支持两种继承方式：接口继承和实现继
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="原型链" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>原型、原型链以及继承（一）</title>
    <link href="http://yoursite.com/2017/08/13/%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%BB%A5%E5%8F%8A%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/08/13/原型、原型链以及继承（一）/</id>
    <published>2017-08-13T09:33:39.000Z</published>
    <updated>2017-08-14T10:07:01.532Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对 【<em>小红书</em>】 中原型和继承进行了归纳总结。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ul>
<li>创建的每一个函数都包含一个 <code>prototype</code> （原型）属性，这个属性是一个指针，指向 <strong>原型对象</strong> （即平时所说的 <strong>“原型”</strong>）；</li>
<li>所有的原型对象都会自动获得一个 <code>constructor</code> （构造函数）属性，这个属性也是一个指针，指向一个包含 <code>prototype</code> 属性所在的函数；</li>
<li>调用构造函数创建实例，每个实例都包含一个 <code>[[prototype]]</code> （<em>_proto_</em>）属性（内部属性），这个属性还是一个指针，指向构造函数的原型对象。</li>
</ul>
<p><em>解释一下 <code>\_proto\_</code>：在脚本中没有标准的方式访问 [[prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性（<code>\_proto\_</code>），它就相当于是对象实例与构造函数的原型对象之间的一个连接。</em></p>
<p>（对照着下图进行理解）</p>
<p><strong>原型对象的用途：</strong> 包含可以由特定类型的所有实例共享的属性和方法；<br><strong>使用原型对象的好处：</strong> 让所有对象实例共享它所包含的属性和方法，不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中。</p>
<p>下面，直接上代码和图，说明一下各个对象之间的关系。</p>
<p><img src="/img/2017-08-13_001.jpg" alt="各个对象之间的关系"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 创建函数</div><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 给原型对象添加属性和方法</div><div class="line">Person.prototype.name = &quot;Bob&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;student&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">  alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 创建对象实例，并调用方法</div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName();      // &quot;Bob&quot;</div><div class="line"></div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName();      // &quot;Bob&quot;</div><div class="line"></div><div class="line">alert(person1.sayName == person2.sayName);    // true</div></pre></td></tr></table></figure>
<p>上面代码中，首先创建了一个名为 <code>Person</code> 的构造函数。由图可以看出，<code>Person</code> 函数有一个 <code>prototype</code> 属性，它是一个指针，指向该函数的原型对象（<code>Person Prototype</code>）；紧接着，给原型对象添加属性和方法，这些属性和方法可以由对象实例共享；最后，使用构造函数来创建对象实例，并调用方法。这里创建了两个对象实例：<code>person1</code> 和 <code>person2</code>，他们拥有相同的属性和方法，因此最后一句代码弹出的是 <code>true</code>。</p>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><h4 id="对象实例与原型对象的关系"><a href="#对象实例与原型对象的关系" class="headerlink" title="对象实例与原型对象的关系"></a>对象实例与原型对象的关系</h4><ul>
<li><p><strong>isPrototypeOf():</strong> 判断对象实例的 [[prototype]] 内部属性是否指向原型对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Person.prototype.isPrototypeOf(person1));    // true</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.getPrototypeOf():</strong> 该方法返回 [[prototype]] 的值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Object.getPrototypeOf(person1));    // Person.prototype</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="实例对象访问属性"><a href="#实例对象访问属性" class="headerlink" title="实例对象访问属性"></a>实例对象访问属性</h4><p>每当代码读取某个实例对象的属性时，都会按一下步骤来执行：</p>
<ul>
<li>首先搜索实例对象本身是否具有给定名字的属性，如果有则返回该属性的值；</li>
<li>如果没有，则在原型对象中进行搜索，找到了则返回该属性的值。</li>
</ul>
<p>原型对象最初只包含 <code>constructor</code> 属性，该属性也是共享的，对象实例可以访问到。</p>
<p>虽然可以通过对象实例访问保存在原型对象中的值，但却不能通过对象实例重写原型对象中的值。（如果实例对象中有一个属性与原型对象中的属性同名，则根据访问顺序，原型对象中的同名属性会被屏蔽；可以通过 <code>delete</code> 删除实例属性，让原型对象中的同名属性重见天日。）</p>
<h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h4><p>用来判断某个属性是来源于实例对象本身，还是来源于原型对象<br>（只要当该对象来源于实例对象本身的时候，该方法才会返回 <code>true</code>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Bob&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">person1.name = &quot;Alice&quot;;</div><div class="line"></div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));   // true</div><div class="line">alert(person1.hasOwnProperty(&quot;age&quot;));   // false</div></pre></td></tr></table></figure></p>
<h4 id="原型对象与-in-操作符"><a href="#原型对象与-in-操作符" class="headerlink" title="原型对象与 in 操作符"></a>原型对象与 in 操作符</h4><ul>
<li><p>单独使用<br>如果通过实例对象能够访问到给定的属性（无论来源于哪里），都会返回 <code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = &quot;Bob&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">person1.name = &quot;Alice&quot;;</div><div class="line">alert(&quot;name&quot; in person1);    // true</div><div class="line">alert(&quot;age&quot; in person1);    // true</div></pre></td></tr></table></figure>
</li>
<li><p>在 <code>for-in</code> 循环中使用<br>返回的是所有能够通过实例对象访问的、可枚举的属性（无论该属性来源于哪里）。</p>
</li>
</ul>
<p><font color="red">注意：</font>如果某个属性在原型对象中是不可枚举的（即该属性的 <code>[[Enumerable]]</code> 被设置为 <code>false</code>），实例对象中有一个同名属性，则该实例属性还是会在 <code>for-in</code> 循环中返回的。（<em>所有开发人员定义的属性都是可枚举的，只有在IE8及更早版本中例外</em>）</p>
<p>可替代方法：<code>Object.keys()</code> 和 <code>Object.getOwnPropertyNames()</code></p>
<h4 id="原型语法的简化"><a href="#原型语法的简化" class="headerlink" title="原型语法的简化"></a>原型语法的简化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">  name: &quot;Bob&quot;,</div><div class="line">  age: 29,</div><div class="line">  job: &quot;student&quot;,</div><div class="line">  sayName: function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，不需要在每次添加属性和方法的时候都敲一遍 <code>Person.prototype</code>，而是将 <code>Person.prototype</code> 设置为等于一个以对象字面量形式创建的新对象。</p>
<p><font color="red">注意：</font>这里 <code>constructor</code> 属性不再指向 <code>Person</code> 构造函数，因为这里完全重写了 <code>Person.prototype</code> 对象。</p>
<h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><ul>
<li>可以随时为原型对象添加属性和方法，并且修改能够立即在所有对象实例中反应出来；</li>
<li>如果重写整个原型对象，实例对象中的 <code>[[prototype]]</code> 内部属性指向的还是最初的那个原型对象，而不是这个新的原型对象；</li>
</ul>
<h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><ul>
<li>所有实例在默认情况下会取得相同的属性值，在某种程度上会带来一些不方便；</li>
<li>由其共享的本性所导致 —— <font color="red">特别是包含引用类型值的属性的时候</font>；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">  constructor: Person,</div><div class="line">  name: &quot;Bob&quot;,</div><div class="line">  age: 29,</div><div class="line">  friends: [&quot;Alice&quot;,&quot;Lucy&quot;]</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">person1.friends.push(&quot;Cindy&quot;);</div><div class="line">alert(person1.friends);   // &quot;Alice, Lucy, Cindy&quot;</div><div class="line">alert(person2.friends);   // &quot;Alice, Lucy, Cindy&quot;</div><div class="line">alert(person1.friends == person2.friends);  // true</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，<code>Person.prototype</code> 原型对象中的 <code>friends</code> 属性是一个数组，而 <code>person1</code> 和 <code>person2</code> 这两个实例对象访问属性 <code>friends</code> 时，其实指向的是同一个数组，所以对 <code>person1.friends</code> 的修改也会在 <code>person2.friends</code> 上反映出来。</p>
<p>但是……<br>如果是在 <code>person1</code> 实例对象中重写 <code>friends</code> 属性就不一样了。然而如果想在原先属性的基础上做修改，这种方法还是解决不了问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">  constructor: Person,</div><div class="line">  name: &quot;Bob&quot;,</div><div class="line">  age: 29,</div><div class="line">  friends: [&quot;Alice&quot;,&quot;Lucy&quot;]</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line">person1.friends = [&quot;Alice&quot;,&quot;Lucy&quot;,&quot;Cindy&quot;];</div><div class="line">alert(person1.friends);    // &quot;Alice, Lucy, Cindy&quot;</div><div class="line">alert(person2.friends);    // &quot;Alice, Lucy&quot;</div></pre></td></tr></table></figure></p>
<p>因此，基于以上问题，原型模式很少单独使用。</p>
<h3 id="对原型模式的改进"><a href="#对原型模式的改进" class="headerlink" title="对原型模式的改进"></a>对原型模式的改进</h3><h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>—— 使用最广泛、认同度最高</p>
<ul>
<li><strong>构造函数模式：</strong> 定义实例属性；</li>
<li><strong>原型模式：</strong> 定义方法和共享的属性；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 构造函数模式</div><div class="line">function Person(name,age)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.age = age;</div><div class="line">  this.friends = [&quot;Alice&quot;,&quot;Lucy&quot;];</div><div class="line">&#125;</div><div class="line">// 原型模式</div><div class="line">Person.prototype = &#123;</div><div class="line">  constructor: Person,</div><div class="line">  sayName: function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Bob&quot;,29);</div><div class="line">var person2 = new Person(&quot;Petter&quot;,28);</div><div class="line"></div><div class="line">person1.friends.push(&quot;Cindy&quot;);</div><div class="line">alert(person1.friends);   // &quot;Alice,Lucy,Cindy&quot;</div><div class="line">alert(person2.friends);   // &quot;Alice,Lucy&quot;</div><div class="line">alert(person1.friends == person2.friends);    // false</div><div class="line">alert(person1.sayName == person2.sayName);    // true</div></pre></td></tr></table></figure>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><ul>
<li>把所有信息都封装在构造函数中，通过在构造函数中初始化原型对象（仅在必要的情况下），保持了同时使用构造函数和原型的优点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person(name,age)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.age = age;</div><div class="line">  this.friends = [&quot;Alice&quot;,&quot;Lucy&quot;];</div><div class="line"></div><div class="line">  if(typeof this.sayName != &quot;function&quot;)&#123;</div><div class="line">    Person.prototype.sayName = function()&#123;</div><div class="line">      alert(this.name);</div><div class="line">    &#125;</div><div class="line">    Person.job = &quot;student&quot;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var person1 = new Person(&quot;Bob&quot;, 29);</div><div class="line">  person1.sayName();    // Bob</div><div class="line">  alert(person1.job);    // student</div></pre></td></tr></table></figure>
<p>以上代码中，只有在 <code>sayName()</code> 方法不存在的情况下，才会将 <code>sayName()</code> 方法和 <code>job</code> 属性添加到原型中。<code>if</code> 语句部分，<strong>只会在初次调用构造函数时才执行，</strong> 之后原型对象已经初始化，不需要再做什么修改。<br><code>if</code> 语句检查的可以是初始化之后应该存在的任何属性和方法，如果不止一个，也不需要每一个属性和方法都检查一遍，只要检查其中一个即可。（上面代码就只检查了一个）</p>
<h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是对 【&lt;em&gt;小红书&lt;/em&gt;】 中原型和继承进行了归纳总结。&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建的每一个函数都包含一
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>cookie 和 session</title>
    <link href="http://yoursite.com/2017/08/11/cookie-%E5%92%8C-session/"/>
    <id>http://yoursite.com/2017/08/11/cookie-和-session/</id>
    <published>2017-08-11T08:11:32.000Z</published>
    <updated>2017-08-11T12:33:38.207Z</updated>
    
    <content type="html"><![CDATA[<p>首先简要的说一下 <code>cookie</code> 和 <code>session</code> 分别是用来干什么的？<br><strong>cookie</strong><br>可以用来跟踪会话，也可以用来保存用户喜好或者保存用户名密码；</p>
<p><strong>session</strong><br>用来跟踪会话；</p>
<h3 id="cookie-和-session-的原理"><a href="#cookie-和-session-的原理" class="headerlink" title="cookie 和 session 的原理"></a>cookie 和 session 的原理</h3><p>下面内容来源于知乎上的回答，作者：郭无心，<a href="https://www.zhihu.com/question/19786827/answer/66706108" target="_blank" rel="external">cookie 和 session 的区别</a>，个人觉得这段原理解释非常通俗易懂，故在此引用。</p>
<h4 id="保存用户名密码"><a href="#保存用户名密码" class="headerlink" title="保存用户名密码"></a>保存用户名密码</h4><p>当我们平时登录网站点击保存用户名和密码时，一般保存的都是 <code>cookie</code>，将用户名和密码的 <code>cookie</code> 保存到硬盘中，这样再次登录的时候浏览器直接将 <code>cookie</code> 发送到服务器端验证即可，这样对于用户来说很方便。直接将 <code>uesername</code> 和 <code>password</code> 保存到客户端，这当然是很不安全的，对此浏览器也可以进行加密解密，而每个浏览器都可以有自己的加密解密方式。</p>
<h4 id="保存用户喜好"><a href="#保存用户喜好" class="headerlink" title="保存用户喜好"></a>保存用户喜好</h4><p>用户喜欢的网页背景色（比如 <code>QQ</code> 空间的背景），这些信息也是可以用个 <code>cookie</code> 保存到客户端的，这样登录之后浏览器就可以直接获取相应的偏好设置。</p>
<h4 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h4><p>比如某些网站中网页有不同的访问权限，有只能登录的用户访问的网页，或者用户级别不同不能访问的，但 <code>http</code>请求是无状态的，每次访问服务器端是不知道是否是登录用户。这样的话，我们很自然的会想到在 <code>http</code> 请求报文中加入登录标识，而这个登录标识就可以是 <code>cookie</code>。服务器端保存有所有登录用户的 cookie，这样请求报文来了之后，将登录标识 <code>cookie</code> 与服务器端的 <code>cookie</code> 进行比较即可。</p>
<p>再比如购物网站，多次点击添加商品都购物车，客户端很容易知道哪些物品在购物车中，但是服务器端怎么知道每次添加的物品放到哪个登录用户的购物车中呢？也需要请求报文中带着 <code>cookie</code> 才行（在不登录的情况下，京东也可以不断添加商品，推测应该是登录的时候一并创建 <code>cookie</code> 并且发送物品信息）。</p>
<p>这些 <code>cookie</code> 都是为了跟踪会话用的，所以客户端有，服务器端也有，并且服务器端有全部的会话 <code>cookie</code>。</p>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>后来衍生出 <code>session</code> 技术，之所以出现 <code>session</code> 技术，主要是为了安全，而 <code>session</code> 技术需要用到 <code>cookie</code>。</p>
<p>我们都知道，<code>http</code> 是无状态的协议，客户每次读取 <code>web</code> 页面时，服务器都会打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢？ <code>session</code> 就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过 <code>SessionID</code> 来区分不同的客户。<code>session</code> 以 <code>cookie</code> 或 <code>URL</code> 重写为基础，默认使用 <code>cookie</code> 来实现，系统会创造一个名为 <code>JSESSIONID</code> 的输出 <code>cookie</code>，我们把它称为 <code>session cookie</code>，以区别 <code>persistent cookies</code>（也即我们通常所说的 <code>cookie</code>）。这里需要注意的是，<code>session cookie</code> 是存储于浏览器内存中的，并不是写到硬盘上的，所以通常情况下我们是看不到 <code>JSESSIONID</code> 的，但是当我们把浏览器的 <code>cookie</code> 禁止后，<code>web</code> 服务器会采用 <code>URL</code> 重写的方式传递 <code>SessionID</code>，我们就可以在地址栏看到 <code>sessionid=KWJHUG6JJM65HS2K6</code> 之类的字符串。</p>
<h4 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h4><p><img src="/img/2017-08-11_001.png" alt="HTTP 请求报文"><br>上图中， <code>HTTP</code> 请求报文头的最后一行有 <code>cookie</code>，不过是 <code>JSESSIONID</code> 的 <code>cookie</code> 值。<br>一般 <code>Cookie</code> 形式如下：<br><code>Cookie：$Version=1;Skin=new;jsessionid=5F4771183629C9834F8382E23BE13C4C</code><br>前两个值为偏好设置，最后一个为 jsessionid。</p>
<p>服务器端是怎么知道客户端的多个请求是属于哪一个 <code>Session</code> 呢？<br><code>jsessionid</code>，是通过 <code>HTTP</code> 请求报文头的 <code>Cookie</code> 属性的 <code>jsessionid</code> 的值关联起来的。（当然也可以通过重写 URL 的方式来将会话 <code>ID</code> 附带在每个 <code>URL</code> 后面）</p>
<p>以上，引用内容结束！</p>
<hr>
<h3 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="headerlink" title="cookie 和 session 的区别"></a>cookie 和 session 的区别</h3><h4 id="目的（用途）不同"><a href="#目的（用途）不同" class="headerlink" title="目的（用途）不同"></a>目的（用途）不同</h4><p>cookie 可以用来跟踪会话，也可以用来保存用户喜好或者保存用户名密码，其主要是为了解决 HTTP 协议无状态的缺陷；<br>session 用来跟踪会话，主要是为了安全；</p>
<h4 id="隐私策略（存储位置）不同"><a href="#隐私策略（存储位置）不同" class="headerlink" title="隐私策略（存储位置）不同"></a>隐私策略（存储位置）不同</h4><p><strong>cookie</strong> 保存在客户端，对客户端是可见的。客户端的一些程序可能会窥探、复制甚至修改 <code>cookie</code> 中的内容，存在安全隐患；<br><strong>session</strong> 保存在服务器端，对客户端是透明的，不存在敏感信息泄露的风险；</p>
<h4 id="有效期不同"><a href="#有效期不同" class="headerlink" title="有效期不同"></a>有效期不同</h4><p><strong>cookie</strong><br>如果不设置过期时间，则表示这个 <code>cookie</code> 的生命周期为浏览器会话期间，关闭浏览器窗口，<code>cookie</code> 就消失。（会话 <code>cookie</code>，一般不存储在硬盘上，而是保存在内存中）<br>如果设置了过期时间，则只有超过了过期时间，<code>cookie</code> 才会消失。（这种情况下，浏览器会把 <code>cookie</code> 保存到硬盘上，存储在硬盘上的 <code>cookie</code> 可以在不同浏览器进程间共享）因此我们可以完成信息永久有效的效果，即设置 <code>cookie</code> 的过期时间属性为一个很大很大的数字即可。</p>
<p><strong>session</strong><br><code>session</code> 依赖于 <code>JSESSIONID</code> 的 <code>cookie</code>，而 <code>Cookie JSESSIONID</code> 的过期时间默认为 <code>-1</code>，只要关闭浏览器窗口，该 <code>session</code> 就会失效。因此，它无法完成信息永久有效的效果。</p>
<h4 id="服务器压力不同"><a href="#服务器压力不同" class="headerlink" title="服务器压力不同"></a>服务器压力不同</h4><p>前面在 <em>存储位置不同</em> 中提到了两者的存储位置。<br><strong>cookie</strong> 保存客户端，不占服务器资源；如果并发访问的用户很多，<code>cookie</code> 是不错的选择；<br><strong>session</strong> 保存在服务器端，每一个用户都会产生一个 <code>sessionid</code>，如果并发访问的用户很多，就会耗费大量的内存。</p>
<h4 id="浏览器支持不同"><a href="#浏览器支持不同" class="headerlink" title="浏览器支持不同"></a>浏览器支持不同</h4><p><strong>cookie</strong> 需要客户端浏览器的支持。假如客户端禁用了 <code>cookie</code>，或者不支持 <code>cookie</code>，则会话跟踪就会失效。<br>而对于 <strong>session</strong> 而言，如果客户端浏览器持 <code>cookie</code>，<code>session</code> 可以通过重写 <code>URL</code> 的方式将 <code>ID</code> 附带在每个 <code>URL</code> 后面。</p>
<p>假如客户端支持 <code>cookie</code>，则 <strong>cookie</strong> 既能设为本浏览器窗口以及子窗口内有效（把过期时间设为 <code>-1</code>），也能设为一切浏览器窗口内有效（把过期时间设为某个大于 <code>0</code> 的整数）；<br>但 <strong>session</strong> 只能在本浏览器窗口以及其子窗口内有效。</p>
<h4 id="跨域支持上的不同"><a href="#跨域支持上的不同" class="headerlink" title="跨域支持上的不同"></a>跨域支持上的不同</h4><p><strong>cookie</strong> 支持跨域名访问，例如将 <code>domain</code> 属性设置为 <code>“.biaodianfu.com”</code>，则以 <code>“.biaodianfu.com”</code> 为后缀的一切域名均能够访问该 <code>cookie</code>;<br><strong>session</strong> 不支持跨域名访问，尽在它所在的域名内有效；</p>
<h4 id="存储类型不同"><a href="#存储类型不同" class="headerlink" title="存储类型不同"></a>存储类型不同</h4><p><strong>cookie</strong> 中只能保管 <code>ASCII</code> 字符串，如果需要存储 <code>Unicode</code> 字符或者二进制数据，需要先进行编码；也不能存储 <code>java</code> 对象；<br><strong>session</strong> 中能够存储任何类型的数据，包括且不仅限于 <code>String、Integer、List、Map</code>等；也能直接保管 <code>Java</code> 类，对象等；</p>
<h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>【Q1】</strong> 如何设置 <code>cookie</code>？<br><code>cookie</code> 是以键值对的形式保存的，即 <code>key=value</code> 的格式，各个 <code>cookie</code> 之间一般是以 <code>“;”</code> 分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cookie.name = value;</div><div class="line"></div><div class="line">document.cookie = &quot;name&quot; + uesername;</div><div class="line">// 保存变量 username 的值(&apos;jack&apos;)到 cookie 中，key 值为 name</div></pre></td></tr></table></figure></p>
<p><strong>【Q2】</strong> 如何改变/设置 <code>session</code> 的有效期？<br>方法一<br>在主页面中写入下面两句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpSession session = request.getSession(true);</div><div class="line">session.setMaxInactiveInterval(3600);  // 3600秒（服务器端的3600秒，而不是客户端的）</div></pre></td></tr></table></figure></p>
<p>方法二<br>在项目的 <code>web.xml</code> 中设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;session-config&gt;</div><div class="line">&lt;session-timeout&gt;60&lt;/session-timeout&gt;</div><div class="line">&lt;session-config&gt;</div><div class="line">// 60 指的是 60 分钟</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先简要的说一下 &lt;code&gt;cookie&lt;/code&gt; 和 &lt;code&gt;session&lt;/code&gt; 分别是用来干什么的？&lt;br&gt;&lt;strong&gt;cookie&lt;/strong&gt;&lt;br&gt;可以用来跟踪会话，也可以用来保存用户喜好或者保存用户名密码；&lt;/p&gt;
&lt;p&gt;&lt;stron
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
      <category term="session" scheme="http://yoursite.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>关于闭包</title>
    <link href="http://yoursite.com/2017/08/09/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/08/09/关于闭包/</id>
    <published>2017-08-09T15:01:54.000Z</published>
    <updated>2017-08-10T15:30:51.330Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于闭包的一些知识点总结</p>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包?"></a>什么是闭包?</h3><p>闭包就是指有权访问另一个函数作用域中的变量的函数</p>
<h3 id="闭包的创建方式"><a href="#闭包的创建方式" class="headerlink" title="闭包的创建方式"></a>闭包的创建方式</h3><p>创建闭包的常见方式：在一个函数内部创建另一个函数。</p>
<p>内部函数的作用域链包含外部函数的作用域，因此可以访问外部函数作用域中的变量</p>
<h4 id="什么是作用域链？"><a href="#什么是作用域链？" class="headerlink" title="什么是作用域链？"></a>什么是作用域链？</h4><p>本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p>
<h3 id="闭包的副作用"><a href="#闭包的副作用" class="headerlink" title="闭包的副作用"></a>闭包的副作用</h3><p>（其中前两条由作用域链的配置机制引起）<br><strong>由于闭包会携带包含他的函数的作用域，因此会比其他函数占用更多的内存；</strong><br><strong>只能取得包含函数中任何变量的最后一个值；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function createFunctions()&#123;</div><div class="line">    var result = [];</div><div class="line"></div><div class="line">    for(var i = 0; i &lt; 10; i ++)&#123;</div><div class="line">        result[i] = function()&#123;</div><div class="line">            return i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">creatFunctions();     // [10,10,10,10,10,10,10,10,10,10]</div></pre></td></tr></table></figure>
<p>原因：<br>每个函数的作用域链中都保存着 createFunctions() 函数的活动对象，所以他们引用的都是同一个变量 i 。<br>闭包保存的是变量对象，而不是某个特殊的变量；</p>
<p>解决办法：<br>通过创建另一个匿名函数，强制让闭包的行为符合预期；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createFunctions()&#123;</div><div class="line">    var result = [];</div><div class="line"></div><div class="line">    for(var i = 0; i &lt; 10; i ++)&#123;</div><div class="line">        result[i] = function(num)&#123;</div><div class="line">            return function()&#123;</div><div class="line">                return num;</div><div class="line">            &#125;</div><div class="line">        &#125;(i)</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">// 每个函数都会返回不同的索引值</div></pre></td></tr></table></figure>
<p>以上代码中，没有直接把闭包赋给数组，而是定义了另一个匿名函数，并将立即执行匿名函数的结果赋给数组。这个匿名函数有一个参数 num ，也就是最终的函数要返回的值。在调用每个匿名函数时，就传入了变量 i。由于函数参数是按值传递的，所以就会将变量 i 的当前值赋值给参数 num。</p>
<p><strong>在闭包中使用 this对象可能会导致一些问题：没有取得其包含作用域（外部作用域）的 this 对象；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var obj = &#123;</div><div class="line">    name: &apos;Bob&apos;,</div><div class="line">    getName: function()&#123;</div><div class="line">        return function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">alert(obj.getName()());    // &quot;The Window&quot;(在非严格模式下)</div></pre></td></tr></table></figure>
<p>原因：<br>匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window ；<br>每个函数在被调用时都会自动取得两个特殊变量（this 和 arguments），内部函数在搜索这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量；</p>
<p>解决办法：<br>把外部作用域中的 this 对象保存在一个闭包能够访问到的变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var obj = &#123;</div><div class="line">    name: &apos;Bob&apos;,</div><div class="line">    getName: function()&#123;</div><div class="line">        var that = this；</div><div class="line">        return function()&#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">alert(obj.getName()());    // &quot;Bob&quot;</div></pre></td></tr></table></figure>
<p><strong>内存泄漏：如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function assignHandler()&#123;</div><div class="line">    var element = document.getElementById(&apos;someElement&apos;);</div><div class="line">    element.onclick = function()&#123;</div><div class="line">        alert(&apos;element.id&apos;);</div><div class="line">    &#125;;</div><div class="line">&#125;       </div><div class="line">// 只要匿名函数存在，element的引用次数至少是1，因此它所占用的内存就永远不会被回收。</div></pre></td></tr></table></figure>
<p>将代码做如下改进，即可减少引用数，确保正常回收占用的内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function assignHandler()&#123;</div><div class="line">    var element = document.getElementById(&apos;someElement&apos;);</div><div class="line">    var id = element.id;</div><div class="line">    element.onclick = function()&#123;</div><div class="line">        alert(id);</div><div class="line">    &#125;;</div><div class="line">    element = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h3><p>参考博文【<a href="http://www.cnblogs.com/star-studio/archive/2011/06/22/2086493.html" target="_blank" rel="external">http://www.cnblogs.com/star-studio/archive/2011/06/22/2086493.html</a>】</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于闭包的一些知识点总结&lt;/p&gt;
&lt;h3 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包?&quot;&gt;&lt;/a&gt;什么是闭包?&lt;/h3&gt;&lt;p&gt;闭包就是指有权访问另一个函数作用域中的变量的函数&lt;/p&gt;
&lt;h3 
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JS的六种数据类型</title>
    <link href="http://yoursite.com/2017/08/06/JS%E7%9A%84%E5%85%AD%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/08/06/JS的六种数据类型/</id>
    <published>2017-08-06T13:44:24.000Z</published>
    <updated>2017-08-07T07:40:59.479Z</updated>
    
    <content type="html"><![CDATA[<p>JS有六种数据类型，可以大致分为以下两类：</p>
<ul>
<li><strong>基本数据类型：</strong> Number、String、Boolean、Undefined、Null；</li>
<li><strong>复杂（引用）数据类型：</strong> Object(Array、Date、RegExp…)；</li>
</ul>
<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>Null 表示“无”的对象，转换为数值时为0<br>典型用法：</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象；</li>
<li>作为对象原型链的终点。</li>
</ul>
<h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p>Undefined 表示一个“无”的原始值，转换为数值时为NaN<br>典型用法：</p>
<ul>
<li>变量被声明，但未赋值；</li>
<li>调用函数时，应该提供的参数没有提供，该参数=undefined；</li>
<li>对象没有赋值的属性，该属性的值=undefined；</li>
<li>函数没有返回值，默认返回undefined。</li>
</ul>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>只有两个值：true 和 false；</p>
<h4 id="转换函数-Boolean"><a href="#转换函数-Boolean" class="headerlink" title="转换函数 Boolean()"></a>转换函数 Boolean()</h4><p>JS 所有类型的值都有与这两个Boolean值等价的值，具体的转换关系见下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">转换为true的值</th>
<th style="text-align:left">转换为flase的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">true</td>
<td style="text-align:left">flase</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">任何非空的字符串</td>
<td style="text-align:left">“”(空字符串)</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">任何非0数值（包括无穷大）</td>
<td style="text-align:left">0 和 NaN</td>
</tr>
<tr>
<td style="text-align:left">Object</td>
<td style="text-align:left">任何对象</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">Undefined</td>
<td style="text-align:left">不使用</td>
<td style="text-align:left">undefined</td>
</tr>
</tbody>
</table>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JS 中 Number 可以表示： 整数和浮点数值，以及二进制，八进制（0开头），十六进制（0x开头）的数。</p>
<h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>最大/最小值：Number.MAX_VALUE，Number.MIN_VALUE；<br>无穷大/无穷小：infinity， -infinity；<br>isFinity()函数：确定一个数是不是有穷的。</p>
<h4 id="NaN（Not-a-Number，一个特殊的数值）"><a href="#NaN（Not-a-Number，一个特殊的数值）" class="headerlink" title="NaN（Not a Number，一个特殊的数值）"></a>NaN（Not a Number，一个特殊的数值）</h4><p>用于表示本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了），在ECMAScript中，任何数除以0会返回NaN（实际上只有0除以0才会返回NaN，正数除以0返回Infinity，负数除以0返回-Infinity）；</p>
<p>任何涉及NaN的操作都会返回NaN；</p>
<p>NaN与任何值都不相等，包括NaN本身；</p>
<p>isNaN()函数：判断接收到的参数能否转换为数值，如果不能返回true，如果能则返回false，该参数可以是任何类型。<br>数值转换：Number()、parseInt()、parseFloat()</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>可以由双引号（” “）或单引号（’ ‘）表示；</p>
<h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h4><p>每个字符串都有一个length属性，返回字符串的长度；</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>字符串是不可变的（字符串值的内容是不可改变的）：要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量；</p>
<h4 id="转换为字符串两种方法"><a href="#转换为字符串两种方法" class="headerlink" title="转换为字符串两种方法"></a>转换为字符串两种方法</h4><p><strong>toString()</strong></p>
<ul>
<li>除了 null 和 undefined （数值，对象、布尔值和字符串）都有这个方法；</li>
<li>在调用数值的toString()方法时，可以传递一个参数，作为输出数值的基数；（比如：二进制、八进制、十六进制等）；</li>
</ul>
<p><strong>String()：</strong> 在不知道要转换的值是否为 null 和 undefined 时，可以使用</p>
<ul>
<li>null，返回“null”，undefined，返回“undefined”，其他返回值与 toString() 方法一样；</li>
<li>如果要转换的值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果；</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>JS 中对象是一组数据和功能的集合；</p>
<p>对象也可看做属性的容器，每个属性都是一个名/值对；属性的名字可以是包括空字符串在内的任意字符串。属性值可以是除undefined值之外的任何值。</p>
<p>对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS有六种数据类型，可以大致分为以下两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本数据类型：&lt;/strong&gt; Number、String、Boolean、Undefined、Null；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复杂（引用）数据类型：&lt;/strong&gt; O
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于 Ajax</title>
    <link href="http://yoursite.com/2017/08/06/%E5%85%B3%E4%BA%8E-Ajax/"/>
    <id>http://yoursite.com/2017/08/06/关于-Ajax/</id>
    <published>2017-08-06T10:16:10.000Z</published>
    <updated>2017-08-12T15:14:23.533Z</updated>
    
    <content type="html"><![CDATA[<p>本文罗列了一些与 Ajax 相关的知识点。<br>参考文章：【<a href="http://www.cnblogs.com/aure/p/4632825.html" target="_blank" rel="external">Ajax中XML和JSON格式的优劣比较</a>】</p>
<h3 id="Ajax-是什么？"><a href="#Ajax-是什么？" class="headerlink" title="Ajax 是什么？"></a>Ajax 是什么？</h3><p>首先来说一说什么是Ajax？<br>Ajax 全称为 “Asynchronous JavaScript and XML” （异步 <code>JavaScript</code> 和 <code>XML</code> ），<code>JavaScript</code> 通过异步的形式去操作 <code>XML</code> 文档;</p>
<h4 id="一个-Ajax-程序"><a href="#一个-Ajax-程序" class="headerlink" title="一个 Ajax 程序"></a>一个 Ajax 程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();           // 创建XHR对象——打开浏览器</div><div class="line">    xhr.open(&apos;get&apos;,&apos;1.txt&apos;,true);         // 启动一个请求以备用——在地址栏中输入地址</div><div class="line">    xhr.send();                           // 发送请求——提交，敲回车</div><div class="line">    // 检测XHR对象的readyState属性——等待服务器返回内容</div><div class="line">    xhr.onreadystatechange = function()&#123;</div><div class="line">        if(xhr.readyState == 4)&#123;</div><div class="line">            alert(xhr.responseText);</div><div class="line">        &#125;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<h4 id="Ajax通信的步骤"><a href="#Ajax通信的步骤" class="headerlink" title="Ajax通信的步骤"></a>Ajax通信的步骤</h4><ol>
<li>新建一个 <code>XMLHttpRequest（XHR）</code> 对象。</li>
<li><code>open</code> 方法表示初始化请求，此时并没有发送。</li>
<li>定义数据返回后的回调函数，里面的代码在 <code>readystatechange</code> 值改变的时候执行。</li>
<li>发送请求。</li>
</ol>
<h3 id="Ajax的交互模型"><a href="#Ajax的交互模型" class="headerlink" title="Ajax的交互模型"></a>Ajax的交互模型</h3><p><img src="/img/2017-08-06_001.jpg" alt="Ajax交互模型"><br>（图片来源于网络）</p>
<h3 id="Ajax传输数据的格式"><a href="#Ajax传输数据的格式" class="headerlink" title="Ajax传输数据的格式"></a>Ajax传输数据的格式</h3><ol>
<li>文本</li>
<li><p><strong>XML(可扩展标记语言)</strong><br>步骤：读取 <code>XML</code> 文档 —&gt; 使用 <code>XML DOM</code> 来循环遍历文档 —&gt; 读取值并存储在变量中<br>优势：</p>
<ul>
<li>格式统一， 符合标准；</li>
<li>容易与其他系统进行远程交互， 数据共享比较方便；</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>XML</code> 文件格式文件庞大，格式复杂， 传输占用带宽；</li>
<li>服务器端和客户端都需要花费大量代码来解析 <code>XML</code> ， 不论服务器端和客户端代码变的异常复杂和不容易维护；</li>
<li>客户端不同浏览器之间解析 <code>XML</code> 的方式不一致， 需要重复编写很多代码；</li>
<li>服务器端和客户端解析 <code>XML</code> 花费资源和时间；</li>
</ul>
</li>
<li><p><strong>JSON(JavaScript Object Notation，一种轻量级的数据交换格式)</strong><br> 步骤：读取 <code>JSON</code> 字符串 —&gt; 用 <code>eval()</code> 处理 <code>JSON</code> 字符串<br> 优势：</p>
<ul>
<li>数据格式比较简单， 易于读写，格式都是压缩的， 占用带宽小；</li>
<li>易于解析这种语言， 客户端 <code>JavaScript</code> 可以简单的通过 <code>eval()</code> 进行 <code>JSON</code> 数据的读取；</li>
<li>支持多种语言， 包括 <code>ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby</code> 等语言服务器端语言， 便于服务器端的解析；</li>
<li>在 <code>PHP</code> 世界, 已经有 <code>PHP-JSON</code> 和 <code>JSON-PHP</code> 出现了， 便于 <code>PHP</code> 序列化后的程序直接调用 <code>. PHP</code> 服务器端的对象、数组等能够直接生 <code>JSON</code> 格式, 便于客户端的访问提取；</li>
<li><p>因为 <code>JSON</code> 格式能够直接为服务器端代码使用， 大大简化了服务器端和客户端的代码开发量， 但是完成的任务不变， 且易于维护；</p>
<p>缺点：</p>
</li>
<li>没有 <code>XML</code> 格式这么推广的深入人心和使用广泛, 没有 <code>XML</code> 那么通用性;</li>
<li><code>JSON</code> 格式目前在 <code>Web Service</code> 中推广还属于初级阶段；</li>
</ul>
</li>
</ol>
<h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><ul>
<li><strong>同步：</strong> 必须等待，这个请求如果没有执行结束，那么就会形成阻塞；</li>
<li><strong>异步：</strong> 发出请求后，仍然可以做其他的事，结果返回时接收响应；</li>
</ul>
<h3 id="如何解决跨域问题？"><a href="#如何解决跨域问题？" class="headerlink" title="如何解决跨域问题？"></a>如何解决跨域问题？</h3><ol>
<li><p>通过修改 <code>document.domain</code> 和隐藏的 <code>IFrame</code> 来实现跨域请求。<br>这种方案可能是最简单的一种跨域请求的方案，但是它同样是一种限制最大的方案。首先，它只能实现在同一个顶级域名下的跨域请求；另外，当在一个页面中还包含有其它的 <code>IFrame</code> 时，可能还会产生安全性异常，拒绝访问。</p>
</li>
<li><p><code>CROS</code> 技术：使用自定义的 <code>HTTP</code> 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。</p>
<p><code>IE</code> 对 <code>CROS</code> 的实现：<code>XDR</code> 类型（异步执行）；<br>其他浏览器对 <code>CROS</code> 的实现：<code>XHR</code> 对象——要请求位于另一个域中的资源，使用标准的 <code>XHR</code> 对象并在 <code>open()</code> 方法中传入绝对 <code>URL</code> 即可；<br>既支持同步执行，也支持异步执行；（最好本地资源使用相对 <code>URL</code> ，远程资源使用绝对 <code>URL</code>)；</p>
</li>
<li><p>图像 <code>Ping</code> —— 使用 <code>&lt;img&gt;</code> 标签（只能用于浏览器用于服务器之间的单向通信）<br>请求的数据通过查询字符串形式发送；<br>缺点：</p>
</li>
</ol>
<ul>
<li>只能发送 <code>GET</code> 请求；</li>
<li>无法访问服务器的响应文本；</li>
</ul>
<ol>
<li><code>JSONP</code>（填充/参数式 <code>JSON</code> ）<br>通过动态 <code>&lt;script&gt;</code> 元素使用，使用时可以为 <code>src</code> 属性指定一个跨域 <code>URL</code>；<br>优点：能够直接访问响应文本，支持在浏览器与服务器之间的双向通信；<br>缺点：</li>
</ol>
<ul>
<li>从其他域中加载代码执行，可能存在安全隐患；</li>
<li>要确定 <code>JSONP</code> 请求是否失败并不容易；</li>
</ul>
<h3 id="【补充】"><a href="#【补充】" class="headerlink" title="【补充】"></a>【补充】</h3><p>【Q1】XmlHttpRequest 对象的局限性？<br>默认情况下，XmlHttpRequest 对象只能访问与包含它的页面位于同一个域中的资源，无法实现跨域访问。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文罗列了一些与 Ajax 相关的知识点。&lt;br&gt;参考文章：【&lt;a href=&quot;http://www.cnblogs.com/aure/p/4632825.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ajax中XML和JSON格式的优劣比较&lt;/
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习 —— 变量的解构赋值</title>
    <link href="http://yoursite.com/2017/08/06/ES6%E5%AD%A6%E4%B9%A0-%E2%80%94%E2%80%94-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2017/08/06/ES6学习-——-变量的解构赋值/</id>
    <published>2017-08-06T02:13:34.000Z</published>
    <updated>2017-08-07T07:39:15.615Z</updated>
    
    <content type="html"><![CDATA[<p>本文是学习 <a href="http://es6.ruanyifeng.com/#docs/destructing" target="_blank" rel="external">阮一峰《ECMAScript 6 入门》 变量的解构赋值</a> 部分的笔记。</p>
<p><strong>解构（Destructing）：</strong> <code>ES6</code> 按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称为 “解构” 。</p>
<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>可以从数组中提取值，按照对应的位置，对变量赋值；</p>
<p><strong>“模式匹配”：</strong> 只要等号两边的模式相同，左边的变量就会被赋予对应的值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [a, b, c] = [1, 2, 3];</div><div class="line">console.log(a);        // 1</div><div class="line">console.log(b);        // 2</div><div class="line">console.log(c);        // 3</div></pre></td></tr></table></figure>
<p><strong>1、使用嵌套数组进行解构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let [a, [[b], c]] = [1, [[2], 3]];</div><div class="line">console.log(a);        // 1</div><div class="line">console.log(b);        // 2</div><div class="line">console.log(c);        // 3</div><div class="line"></div><div class="line">let [ , , third] = [1, 2, 3];</div><div class="line">console.log(third);    // 3</div><div class="line"></div><div class="line">let [first, ...last] = [1,2,3,4];</div><div class="line">console.log(first);   // 1</div><div class="line">console.log(last);    // [2,3,4]</div></pre></td></tr></table></figure>
<p> <strong>2、解构不成功</strong><br> 如果解构不成功，变量的值就等于 <code>undefined</code>（等号右边的模式，只匹配等号左边的一部分）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> let [x,y, ...z] = [1];</div><div class="line">console.log(y);    // undefined</div><div class="line">console.log(z);</div></pre></td></tr></table></figure>
<p> <strong>3、不完全解构</strong><br> 等号左边的模式，只匹配等号右边一部分的数组，这种情况下依然可以解构成功，但是不完全解构。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let [a,b] = [1,2,3];</div><div class="line">console.log(a);    // 1</div><div class="line">console.log(b);    // 2</div><div class="line"></div><div class="line">let [x,[y],z] = [1,[2,3],4];</div><div class="line">console.log(x);    // 1</div><div class="line">console.log(y);    // 2</div><div class="line">cosnole.log(z);    // 4</div></pre></td></tr></table></figure>
<p> <strong>4、等号右边不是数组：报错！</strong><br> 严格的说，应该是不可遍历的解构</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> let [a] = 1;</div><div class="line">let [b] = false;</div><div class="line">let [c] = NaN;</div><div class="line">let [d] = undefined;</div><div class="line">let [e] = null;</div><div class="line">let [f] = &#123;&#125;;</div><div class="line">// 以上代码均会报错</div><div class="line">// 原因：等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个），要么本身就不具备 Iterator 接口（最后一个）。</div></pre></td></tr></table></figure>
<p> 对于 <code>Set</code> 结构（后面内容），也可以使用数组的解构赋值；</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [x,y,z] = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]);</div><div class="line">console.log(x);    // &apos;a&apos;</div></pre></td></tr></table></figure>
 <font color="red">只要某种数据结构具有 <code>Iterator 接口</code>，都可以采用数组形式的解构赋值；</font>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [a = true] = [];</div><div class="line">console.log(a);    // true;</div><div class="line">let[x,y = 2] = [1];    // x=1, y=2</div><div class="line">let[x,y = 2] = [1,undefined]   // x=1, y=2</div></pre></td></tr></table></figure>
<p><strong>1、不生效</strong><br><code>ES6</code> 内部使用严格相等运算符<code>（===）</code>来判断一个位置是否有值。所以一个数组成员不严格等于 <code>undefined</code> ，默认值是不会生效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [a = 1] = [undefined];    // 生效，a = 1</div><div class="line">let [b = 2] = [null];         // 不生效，b = null</div></pre></td></tr></table></figure>
<p><strong>2、表达式</strong><br>如果默认值是一个表达式，则这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function f()&#123;</div><div class="line">    console.log(&apos;a&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">let [x = f()] = [1];    // x=1</div></pre></td></tr></table></figure>
<p>上面代码中，<code>x</code> 能取到值 <code>（1）</code>，所以函数 <code>f()</code> 不会执行。</p>
<p><strong>3、引用解构赋值的其他变量</strong></p>
<p>默认值可以引用结构赋值的其他变量，但是该变量必须已经声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [x = 1, y = x] = [];         // x=1, y=1</div><div class="line">let [x = 1, y = x] = [2];        // x=2, y=2</div><div class="line">let [x = 1, y = x] = [1, 2];     // x=1, y=2</div><div class="line">let [x = y, y = 1] = [];         // Uncaught ReferenceError: y is not defined</div></pre></td></tr></table></figure></p>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><h4 id="1、与数组的不同"><a href="#1、与数组的不同" class="headerlink" title="1、与数组的不同"></a><font color="red">1、与数组的不同</font></h4><p>数组的元素是按次序排列的，变量的取值由它们的位置决定；</p>
<p>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let &#123;name, age, hobby&#125; = &#123;age: 23, name:&quot;Bob&quot;, interest: &quot;running&quot;&#125;;</div><div class="line">console.log(name);    // Bob</div><div class="line">console.log(age);     // 23</div><div class="line">console.log(hobby);   // undefined</div><div class="line"></div><div class="line">let&#123;name:name, age:age, hobby:interest&#125; = &#123;age:23, hobby:&quot;running&quot;, name:&quot;Bob&quot;&#125;;</div><div class="line">console.log(name);    // Bob</div><div class="line">console.log(age);     // 23</div><div class="line">console.log(hobby);   // running</div></pre></td></tr></table></figure>
<p>第一个例子：前两个变量（<code>name</code> 和 <code>age</code>），虽然和等号右边的顺序不一样，但是因为等号右边有两个同名属性，所以依然可以取到值；而最后一个变量（<code>hobby</code>），等号右边不存在同名属性，所以取不到值。</p>
<p>第二个例子：这是对象解构赋值最完整的写法，即等号左边（<code>hobby：interest</code>），其中 <code>hobby</code> 是匹配的模式， <code>interest</code> 才是变量。</p>
<p>等号右边（<code>interest：“running”</code>）， <code>hobby</code> 是变量的同名属性（其实是属性与匹配模式同名），<code>“running”</code> 是值。</p>
<p>看下面两个例子，更好的理解同名属性具体指的是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let &#123;name:who, age: how&#125; = &#123;name:&quot;Bob&quot;, age:25&#125;;</div><div class="line">console.log(who);      // Bob</div><div class="line">console.log(how);      // 25</div><div class="line"></div><div class="line">let &#123;name:who, age: how&#125; = &#123;who:&quot;Bob&quot;, how:25&#125;;</div><div class="line">console.log(who);      // undefined</div><div class="line">console.log(how);      // undefined</div></pre></td></tr></table></figure>
<p>概括一下：对象的解构赋值，首先要找到变量的同名属性，然后再赋值给对应的变量，真正被赋值的是后者，而不是前者。（比如 <code>name：name</code>，真正被赋值的是后面的 <code>name</code> ，而不是前面的 <code>name</code>）。</p>
<h4 id="2、嵌套解构赋值"><a href="#2、嵌套解构赋值" class="headerlink" title="2、嵌套解构赋值"></a>2、嵌套解构赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">    country:&#123;</div><div class="line">        person:&#123;</div><div class="line">            name: &quot;Bob&quot;,</div><div class="line">            age: 25</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123;country, country:&#123;person&#125;, country:&#123;person:&#123;age&#125;&#125;&#125; = obj;</div><div class="line">console.log(country);    // Object &#123;person: Object&#125;</div><div class="line">console.log(person);     // Object &#123;name: &quot;Bob&quot;, age: 25&#125;</div><div class="line">console.log(age);        // 25</div></pre></td></tr></table></figure>
<p>上面代码中，一共有三次解构赋值，先看最后一次 <code>country:{person:{age}}</code> ，<code>country</code> 和 <code>person</code> 在这里都是模式，不是变量，所以只有变量 <code>age</code> 能取到值；如果想要让模式 <code>country</code> 和 <code>person</code> 也要作为变量取到值，就要像前面两次一样。</p>
<p><strong>嵌套赋值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;&#125;;</div><div class="line">let arr = [];</div><div class="line"></div><div class="line">(&#123;foo: obj.prop, bar: arr[0]&#125; = &#123;foo: 123, bar: true&#125;);</div><div class="line">console.log(obj);       // Object &#123;prop: 123&#125;</div><div class="line">console.log(arr);       // [true]</div></pre></td></tr></table></figure>
<h4 id="3、指定默认值"><a href="#3、指定默认值" class="headerlink" title="3、指定默认值"></a>3、指定默认值</h4><p>与数组一样，默认值生效的条件是，对象的属性值严格等于 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</div><div class="line">console.log(x);        // 3</div><div class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</div><div class="line">console.log(x);        // null</div><div class="line"></div><div class="line">var &#123;x, y=2&#125; = &#123;x:1&#125;;     </div><div class="line">console.log(x);        // 1</div><div class="line">console.log(y);        // 2</div><div class="line"></div><div class="line">var &#123;x: y=3&#125; = &#123;&#125;;</div><div class="line">console.log(y);       // 3</div><div class="line"></div><div class="line">var &#123;x: y=3&#125; = &#123;x:1&#125;;</div><div class="line">console.log(y);       // 1</div></pre></td></tr></table></figure>
<h4 id="4、解构失败"><a href="#4、解构失败" class="headerlink" title="4、解构失败"></a>4、解构失败</h4><p>如果解构失败，变量的值等于 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let &#123;name&#125; = &#123;age:25&#125;;</div><div class="line">console.log(name);   // undefined</div><div class="line"></div><div class="line">let &#123;person: &#123;name&#125;&#125; = &#123;age:25&#125;;     //报错</div></pre></td></tr></table></figure>
<p>上面第二个例子，等号左边对象 <code>person</code> 模式对应的变量还是一个对象，进行解构赋值时， <code>person</code> 等于 <code>undefined</code>，再去子属性就会报错。</p>
<p>因此，如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，就会报错。</p>
<h4 id="5、已经声明的变量用于解构赋值（Be-careful！）"><a href="#5、已经声明的变量用于解构赋值（Be-careful！）" class="headerlink" title="5、已经声明的变量用于解构赋值（Be careful！）"></a>5、已经声明的变量用于解构赋值<font color="red">（Be careful！）</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 错误的写法</div><div class="line">let x;</div><div class="line">&#123;x&#125; = &#123;x:1&#125;;     // Uncaught SyntaxError: Unexpected token =</div><div class="line"></div><div class="line">// 正确的写法</div><div class="line">let x;</div><div class="line">(&#123;x&#125; = &#123;x:1&#125;);</div></pre></td></tr></table></figure>
<p>如果是已经声明的一个变量，用于解构赋值时，<code>{x}</code> 会被理解为代码块，从而发生语法错误。此时，应该要避免 <code>{x}</code> 被理解为代码块，可以在最外面加上一个圆括号，如第二个例子，就不会报错。</p>
<h4 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h4><p>解构赋值允许等号左边的模式之中，不放置任何变量名，虽然语法是合理的，但是毫无意义；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(&#123;&#125; = [true, false]);</div><div class="line">(&#123;&#125; = &apos;abc&apos;);</div><div class="line">(&#123;&#125; = []);</div></pre></td></tr></table></figure>
<p>对象的解构赋值，可以很方便的将现有对象的方法，赋值给某个变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &#123;log, sin, cos&#125; = Math;</div></pre></td></tr></table></figure>
<p>这样每次使用Math对象的对数、正弦、余弦方法时，只要直接调用 <code>log</code>，<code>sin</code>，<code>cos</code> 即可。</p>
<p>可以数组进行对象属性的解构，因为数组本质是特殊的对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2,3];</div><div class="line">let &#123;0:first, [arr.length -1]:last&#125; = arr;</div><div class="line">console.log(first);    // 1</div><div class="line">console.log(last);     // 3</div></pre></td></tr></table></figure>
<p>上面第二行代码扩展开来其实就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &#123;0:first, [arr.length -1]:last&#125; = &#123;0:1, 1:2, 2:3&#125;;</div></pre></td></tr></table></figure>
<p>等号右边，每一项冒号的左边其实就是数组的索引值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是学习 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/destructing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰《ECMAScript 6 入门》 变量的解构赋值&lt;/a&gt; 部分的笔记。&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="解构赋值" scheme="http://yoursite.com/tags/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习 —— const命令</title>
    <link href="http://yoursite.com/2017/08/05/ES6%E5%AD%A6%E4%B9%A0-%E2%80%94%E2%80%94-const%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/08/05/ES6学习-——-const命令/</id>
    <published>2017-08-05T02:43:58.000Z</published>
    <updated>2017-08-07T07:39:13.359Z</updated>
    
    <content type="html"><![CDATA[<p>本文是学习 <a href="http://es6.ruanyifeng.com/#docs/let#const-命令" target="_blank" rel="external">阮一峰《ECMAScript 6 入门》 const 命令</a> 部分的笔记。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li><code>const</code> 声明一个只读的常量，一旦声明，常量的值就不能改变；</li>
<li><code>const</code> 一旦声明变量，就必须立即初始化，不能留到以后赋值；</li>
<li><code>const</code> 的作用域：只在声明所在的块级作用域内有效；</li>
<li><code>const</code> 声明的常量不提升，同样也存在暂时性死区，必须先声明再使用；</li>
<li><code>const</code> 声明的常量，不能重复声明；<br>（后面三条用法与 <code>let</code> 命令一致）</li>
</ul>
<p>下面来看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const M = 10；</div><div class="line">M = 2；    // Uncaught TypeError: Assignment to constant variable.</div><div class="line"></div><div class="line">const P;   // Uncaught SyntaxError: Missing initializer in const declaration</div><div class="line"></div><div class="line">if(true)&#123;</div><div class="line">    const Q = 20;</div><div class="line">&#125;</div><div class="line">console.log(Q);    // Uncaught ReferenceError: Q is not defined</div><div class="line"></div><div class="line">if(true)&#123;</div><div class="line">    console.log(K);   // Uncaught ReferenceError: K is not defined</div><div class="line">    const K = 30;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var name = &quot;Bob&quot;;</div><div class="line">let age = 25;</div><div class="line"></div><div class="line">const name = &quot;Alice&quot;;    // Uncaught SyntaxError: Identifier &apos;name&apos; has already been declared</div><div class="line">const age = 18;    // Uncaught SyntaxError: Identifier &apos;age&apos; has already been declared</div></pre></td></tr></table></figure></p>
<h3 id="const-命令的本质"><a href="#const-命令的本质" class="headerlink" title="const 命令的本质"></a>const 命令的本质</h3><p><code>const</code> 实际上保证的，并不是变量的值不能改变，而是变量指向的那个内存地址不能改变。</p>
<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于变量的值不能改变；</p>
<p>而对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code> 命令只能保证这个指针是固定的，而不能保证指针指向的数据结构也是不变的。</p>
<p> 下面分别是这两种类型数据的存储形式：<br> <img src="/img/2017-08-05_001.jpg" alt="基本类型数据"><br> <img src="/img/2017-08-05_002.jpg" alt="引用类型数据"><br> （图片来源于网络）</p>
<font color="red"> 因此，将对象或者数组声明为常量必须非常小心！</font>

<p>下面就对象和数组分别举例进行说明：</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const person = &#123;&#125;;   // 将 person 对象声明为一个常量</div><div class="line"></div><div class="line">person.name = &quot;Bob&quot;;   // 为 person 添加一个属性</div><div class="line">console.log(person.name);   // Bob</div><div class="line"></div><div class="line">person = &#123;&#125;;     // Uncaught TypeError: Assignment to constant variable.</div></pre></td></tr></table></figure>
<p>上面代码中，常量 <code>person</code> 存储的是一个地址，这个地址指向一个对象。而根据前面的分析，不可改变的是这个地址，也就是说不能把 <code>person</code> 指向另一个地址， 但对象本身是可以改变的。因此，给 <code>person</code> 添加新的属性不会报错。</p>
<p>但是如果将 <code>person</code> 指向另一个地址（对象），就会报错。</p>
<p>那有没有办法可以让对象本身也不能改变呢？</p>
<p>可以使用 <code>Object.freeze</code> 方法将对象冻结，从而无法改变对象本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const person = Object.freeze(&#123;&#125;);</div><div class="line"></div><div class="line">person.name = &quot;Alice&quot;;</div><div class="line">// 常规模式下，上面一行不起作用</div><div class="line">// 严格模式下， 会报错！</div></pre></td></tr></table></figure></p>
<p>除了将对象本身冻结之外，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数：（没太看懂）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var constantize = (obj) =&gt; &#123;</div><div class="line">	Object.freeze(obj);</div><div class="line">	Object.keys(obj).forEach((key,i) =&gt; &#123;</div><div class="line">		if(typeof obj[key] === &apos;object&apos;)&#123;   // 如果对象的属性不是“对象”，就不冻结吗？</div><div class="line">			constantize(obj[key]);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const a = [];</div><div class="line">a.push(&apos;hello&apos;);</div><div class="line">a.length = 10;</div><div class="line"></div><div class="line">a = [&apos;world&apos;];    // Uncaught TypeError: Assignment to constant variable.</div></pre></td></tr></table></figure>
<p>常量 <code>a</code> 是一个数组，而数组本身是可以改变的，但是如果将一个新的数组赋值给 <code>a</code> ，就会报错。因此上面代码中，设置数组 <code>a</code> 的属性以及给数组<code>a</code> 添加元素，都是可执行的，而最后将新数组 <code>[&quot;world&quot;]</code> 赋值给数组 <code>a</code> ，就报错了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是学习 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let#const-命令&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰《ECMAScript 6 入门》 const 命令&lt;/a&gt; 部分的笔记。&lt;/p&gt;

    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6 const" scheme="http://yoursite.com/tags/ES6-const/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 —— 排序算法总结</title>
    <link href="http://yoursite.com/2017/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E2%80%94%E2%80%94-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/08/04/数据结构-——-排序算法总结/</id>
    <published>2017-08-04T14:42:23.000Z</published>
    <updated>2017-08-15T12:37:12.739Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了几种经典的排序算法，并对排序算法的性能进行了总结，如果有哪里写的不妥的，还请大家指正批评。同时，也欢迎大家提供更简单有效的算法。</p>
<h3 id="排序算法的性能评估"><a href="#排序算法的性能评估" class="headerlink" title="排序算法的性能评估"></a>排序算法的性能评估</h3><ul>
<li>稳定性（假设记录 <code>a</code> 和记录 <code>b</code> 都位于待排序的序列中）<br>（1）稳定：如果 <code>a</code> 本来就在 <code>b</code> 前面，且 <code>a = b</code>，排序之后 <code>a</code> 仍然在 <code>b</code> 前面；<br>（2）不稳定：如果 <code>a</code> 本来就在 <code>b</code> 前面，且 <code>a = b</code>，排序之后 <code>a</code> 可能出现在 <code>b</code> 后面；</li>
<li>待排序的记录是否全部被放置在内存中<br>（1）内排序：在整个排序过程中，待排序的所有记录全部被放置在内存中；<br>（2）外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行；</li>
<li>时间复杂度：排序算法的时间开销</li>
<li>空间复杂度：排序算法所需的存储空间</li>
<li>算法本身的复杂度</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>下面，将根据 <strong>程杰的《大话数据结构》</strong> ，从易到难对7种排序算法进行整理归纳</p>
<h4 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h4><p><strong>基本思想：</strong> 两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。<br><strong>（1）初级版</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function bubbleSort0(arr)&#123;</div><div class="line">	console.time(&quot;冒泡排序初级版&quot;);</div><div class="line">    var len = arr.length;</div><div class="line">    for(var i = 0; i &lt; len; i ++)&#123;</div><div class="line">        for(var j = i + 1; j &lt; len; j ++)&#123;</div><div class="line">            if(arr[i] &gt; arr[j])&#123;</div><div class="line">                swap(arr,i,j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.timeEnd(&quot;冒泡排序初级版&quot;);</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 交换两个元素</div><div class="line">function swap(arr,i,j)&#123;</div><div class="line">    var temp = arr[i];</div><div class="line">    arr[i] = arr[j];</div><div class="line">    arr[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var num = [2,12,4,56,11,7,21,9,34,16];</div><div class="line">console.log(BubbleSort0(num));        // [2, 4, 7, 9, 11, 12, 16, 21, 34, 56]</div></pre></td></tr></table></figure>
<p>上面代码中，每一次外循环，都是将第 <code>i</code> 个位置的记录， 与它后面的记录进行比较。如果大，则进行交换，这样一次大循环之后，第 <code>i</code> 个位置的记录与后面位置的记录相比就是最小的。</p>
<p><strong>（2）正宗版</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function bubbleSort1(arr)&#123;</div><div class="line">    console.time(&apos;冒泡排序正宗版耗时&apos;);</div><div class="line">    var len = arr.length;</div><div class="line">    for(var i = 0; i &lt; len; i ++)&#123;</div><div class="line">        // j 从后往前循环</div><div class="line">        for(var j = len - 1; j &gt;= i; j --)&#123;</div><div class="line">            if(arr[j-1] &gt; arr[j])&#123;     // 进行两两相邻比较</div><div class="line">                swap(arr, j-1, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.timeEnd(&apos;冒泡排序正宗版耗时&apos;);</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 交换元素</div><div class="line">function swap(arr,i,j)&#123;</div><div class="line">    var tmp = arr[i];</div><div class="line">    arr[i] = arr[j];</div><div class="line">    arr[j] = tmp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var num = [2,12,4,56,11,7,21,9,34,16];</div><div class="line">console.log(bubbleSort1(num));    // [2, 4, 7, 9, 11, 12, 16, 21, 34, 56]</div></pre></td></tr></table></figure></p>
<p>每执行一次外循环，会从排序数组末尾开始两两比较，把较小的记录交换到前面，知道找到最小值放在第 <code>i</code> 个位置。这样在寻找最小值的过程中，也会把较小值移到排序数组的前面，显然这一点要由于冒泡排序初级版。</p>
<p><strong>（3）优化版</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">console.time(&apos;冒泡排序优化版耗时&apos;);</div><div class="line">	var len = arr.length;</div><div class="line">	var flag = true;    // flag用来作为标记</div><div class="line">	for(var i = 0; i &lt; len &amp;&amp; flag; i ++)&#123;    // 当flag = false时，退出循环</div><div class="line">		flag = false;    // flag初始化为false</div><div class="line">		for(var j = len - 1; j &gt;= i; j --)&#123;</div><div class="line">			if(arr[j-1] &gt; arr[j])&#123;</div><div class="line">				swap(arr, j-1, j);</div><div class="line">				flag = true;     // 如果发生数据交换，则flag = true</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	console.timeEnd(&apos;冒泡排序优化版耗时&apos;);</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 交换元素</div><div class="line">function swap(arr, i, j)&#123;</div><div class="line">	var tmp = arr[i];</div><div class="line">	arr[i] = arr[j];</div><div class="line">	arr[j] = tmp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var num = [2,12,4,56,11,7,21,9,34,16];</div><div class="line">console.log(bubbleSort2(num));      // [2, 4, 7, 9, 11, 12, 16, 21, 34, 56]</div></pre></td></tr></table></figure>
<p>假设待排序的序列为 <code>{2,1,3,4,5,6,7,8,9}</code> ， 除了第一和第二个记录需要交换外，其他都已经是正确的顺序了。也就是说，后面的记录其实不需要进行交换，也不需要进行比较。这里设置 <code>flag</code> 变量作为标记，每次外循环的时候判断前一次循环中的内循环是否进行数据交换。如果没有进行数据交换，则退出外循环，说明后面已经是有序的了，不需要再进行比较。</p>
<p>经过这样的改进，冒泡排序在性能上就有了一定的提升，可以避免因已经有序的情况下的无意义循环判断。</p>
<p>这只是冒泡排序算法的一种改进，网上还有很多其他的改进算法，可以参考<font color="blue"><a href="http://mp.weixin.qq.com/s/OH0xlFbeMn_tiiiW_5EetQ" target="_blank" rel="external">十大经典排序算法的JS 版</a></font>。</p>
<p><strong>冒泡排序性能评估</strong></p>
<ul>
<li>稳定性：不稳定；</li>
<li>待排序的记录是否全部被放置在内存中：内排序；</li>
<li>时间复杂度<br>（1）最好的情况：O(n)——已经是正序的；<br>（2）最坏的情况：O(n2)——正好是逆序的；<br>（3）平均的情况：O(n);</li>
<li>空间复杂度：O(1)</li>
<li>算法本身的复杂度：简单</li>
</ul>
<h4 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h4><p><strong>基本思想：</strong> 每一趟通过 n-i 次关键字之间的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i 个记录进行交换；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset = &quot;utf-8&quot;&gt;</div><div class="line">		&lt;title&gt;选择排序&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">			window.onload = function()&#123;</div><div class="line">				function selectionSort(arr)&#123;</div><div class="line">					var len = arr.length;</div><div class="line">					for(var i = 0; i &lt; len; i ++)&#123;</div><div class="line">						var min = i;              // 让最小值的最初索引等于当前的i</div><div class="line">						for(var j = i + 1; j &lt; len; j ++)&#123;      </div><div class="line">							if(arr[j] &lt; arr[min])&#123;      // 如果有小于当前最小值的关键字</div><div class="line">								min = j;              // 将次关键字的索引赋给min</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">						if(i != min)&#123;     // 如果min发生改变，则交换元素</div><div class="line">							swap(arr,i,min);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					return arr;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				function swap(arr,i,j)&#123;</div><div class="line">					var tmp = arr[i];</div><div class="line">					arr[i] = arr[j];</div><div class="line">					arr[j] = tmp;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				var num = [2,12,4,56,11,7,21,9,34,16];</div><div class="line">				console.log(selectionSort(num));</div><div class="line">			&#125;</div><div class="line">		&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>选择排序性能评估</strong></p>
<ul>
<li>时间复杂度<br>无无论最好最差，都是O（n^2）</li>
<li>空间复杂度：O（1）</li>
<li>算法本身复杂度：简单</li>
<li>性能略优于冒泡排序，因为交换移动次数比较少</li>
</ul>
<h4 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h4><p><strong>基本思想：</strong> 将未排序的无序表中的一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function insertionSort(arr)&#123;</div><div class="line">    var len = arr.length;</div><div class="line">    for(var i = 1; i &lt; len; i ++)&#123;</div><div class="line">    	if(arr[i] &lt; arr[i-1])&#123;</div><div class="line">    		var tmp = arr[i];     // 备份</div><div class="line">    		// 遍历有序列表，满足条件的记录后移</div><div class="line">    		for(var j = i-1; arr[j] &gt; tmp; j --)&#123;</div><div class="line">    			arr[j+1] = arr[j];</div><div class="line">    		&#125;</div><div class="line">    		arr[j+1] = tmp;   // 插入到正确的位置</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var num = [2,12,4,56,11,7,21,9,34,16];</div><div class="line">console.log(insertionSort(num));</div></pre></td></tr></table></figure>
<p><strong>插入排序性能评估</strong></p>
<ul>
<li>时间复杂度<br>（1）最好的情况：O(n)——已经是正序的，比较 n-1 次，没有移动；<br>（2）最坏的情况：O(n^2)——正好是逆序的；<br>（3）平均的情况：O(n^2)；</li>
<li>空间复杂度：O(1)</li>
<li>算法本身的复杂度：简单</li>
<li>插入排序比冒泡和选择排序的性能要好一些</li>
</ul>
<h4 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了几种经典的排序算法，并对排序算法的性能进行了总结，如果有哪里写的不妥的，还请大家指正批评。同时，也欢迎大家提供更简单有效的算法。&lt;/p&gt;
&lt;h3 id=&quot;排序算法的性能评估&quot;&gt;&lt;a href=&quot;#排序算法的性能评估&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习 —— let命令</title>
    <link href="http://yoursite.com/2017/08/04/ES6%E5%AD%A6%E4%B9%A0-%E2%80%94%E2%80%94-let%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/08/04/ES6学习-——-let命令/</id>
    <published>2017-08-04T08:09:06.000Z</published>
    <updated>2017-08-07T07:39:11.488Z</updated>
    
    <content type="html"><![CDATA[<p>本文是学习<a href="http://es6.ruanyifeng.com/#docs/let#let-命令" target="_blank" rel="external">阮一峰《ECMAScript 6 入门》 let 命令</a>部分的笔记。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p> <code>let</code> 命令，用来声明变量，用法类似于 <code>var</code> ，但是所声明的变量，只在 <code>let</code> 命令所在的代码快内有效；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    let a = 10;</div><div class="line">    var b = 2;</div><div class="line">&#125;</div><div class="line">a  // ReferenceError: a is not defined</div><div class="line">b  // 2</div></pre></td></tr></table></figure>
<h4 id="let命令在for循环中的应用"><a href="#let命令在for循环中的应用" class="headerlink" title="let命令在for循环中的应用"></a>let命令在for循环中的应用</h4><p>a. for循环的计数器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 10; i ++)&#123;</div><div class="line">    // ……</div><div class="line">&#125;</div><div class="line">console.log(i);    // ReferenceError: i is not defined</div></pre></td></tr></table></figure>
<p>计数器 <code>i</code> 只在 <code>for</code> 循环内有效，在循环外引用就会报错。</p>
<p>b. for循环内声明的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for(let i = 0; i &lt; 10; i ++)&#123;</div><div class="line">    a[i] = function()&#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a[6]();    // 6</div></pre></td></tr></table></figure>
<p>变量 <code>i</code> 是 <code>let</code> 声明的，当前的 <code>i</code> 只在本轮循环中有效，所以每次循环的 <code>i</code> 其实就是一个新的变量。而 JavavScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 <code>i</code> 时，就会在上一轮循环的基础上进行计算，所以最后输出的结果是 <code>6</code> 。</p>
<p>c. <code>for</code> 循环的父作用域和子作用域<br><code>for</code> 循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 10; i ++)&#123;</div><div class="line">    let i = &quot;abc&quot;;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">// abc</div><div class="line">// abc</div><div class="line">// abc</div></pre></td></tr></table></figure>
<p>以上代码运行结果输出三次 <code>“abc”</code>, 这表明函数内部的变量 i 与循环变量 <code>i</code> 不在同一个作用域，有各自单独的作用域。</p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><strong>“变量提升”：</strong> 变量可以在声明之前使用，值为<code>undefined</code>。——  <code>var</code> 命令</p>
<p> <code>let</code> 命令：规定声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(a);   // undefined</div><div class="line">var a = 10;</div><div class="line"></div><div class="line">console.log(b);   // ReferenceError: b is not defined</div><div class="line">let b = 20;</div></pre></td></tr></table></figure>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>在代码块内，使用 <code>let</code> 命令声明变量之前，该变量就是不可用的。这在语法上，称为 <strong>“暂时性死区”（temporal dead zone，简称TDZ）</strong>。</p>
<p>只要块级作用与内存在 <code>let</code> 命令，它所声明的变量就 <strong>“绑定”</strong> 在这个区域，不再受外部的影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var tmp = 123;                // 声明了一个全局变量</div><div class="line">if(true)&#123;</div><div class="line">    tmp = &quot;abc&quot;;              // ReferenceError: tmp is not defined   </div><div class="line">    console.log(tmp);         // ReferenceError: tmp is not defined</div><div class="line"></div><div class="line">    let tmp;</div><div class="line">    console.log(tmp);         // undefined</div><div class="line"></div><div class="line">    tmp = &quot;efd&quot;;</div><div class="line">    console.log(tmp);         // efd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，一开始声明了一个全局变量 <code>tmp</code>，但是块级作用域内 let 又声明了一个局部变量 <code>tmp</code>，导致 <code>tmp</code> 变量绑定在这个块级作用域内。</p>
<p>所以，块级作用域内，在 <code>let</code> 声明变量之前，都属于 <code>tmp</code> 变量的 “暂时性死区”，会报错。</p>
<h4 id="typeof不再百分之百安全"><a href="#typeof不再百分之百安全" class="headerlink" title="typeof不再百分之百安全"></a>typeof不再百分之百安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typeof x;    //ReferenceError: x is not defined</div><div class="line">let x;</div><div class="line"></div><div class="line">typeof y;    // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<p>变量 <code>x</code> 使用 <code>let</code> 命令声明，所以在声明之前，都属于变量 <code>x</code> 的“暂时性死区”，只要用到变量 <code>x</code> 就会报错。而变量 <code>y</code> 没有被声明，使用 <code>typeof</code> 反而不会报错，返回<code>“undefined”</code>。</p>
<h4 id="隐蔽的“暂时性死区”"><a href="#隐蔽的“暂时性死区”" class="headerlink" title="隐蔽的“暂时性死区”"></a>隐蔽的“暂时性死区”</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function test0(x = y, y = 2)&#123;</div><div class="line">    return [x, y];</div><div class="line"> &#125;</div><div class="line"> test0();     // ReferenceError: y is not defined</div><div class="line"></div><div class="line"> function test1(x = 2, y = x)&#123;</div><div class="line">    return [x, y];</div><div class="line"> &#125;</div><div class="line"> test1();     // [2, 2]</div></pre></td></tr></table></figure>
<p>第一个函数 <code>test0</code> 中，调用时候报错的原因是：参数 <code>x</code> 默认值等于另外一个参数 <code>y</code> ，而此时 <code>y</code> 还没有声明，属于“死区”。如果 <code>y</code> 的默认值是 <code>x</code> ，就不会报错，因为此时 <code>x</code> 已经声明了。</p>
<p>第二个函数 <code>test1</code> 中，参数 <code>x</code> 的默认值为 <code>2</code> ，参数 <code>y</code> 的默认值等于参数 <code>x</code> ，而此时 <code>x</code> 已经声明了，所以不会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x = x;     // 不报错</div><div class="line">let y = y;     // ReferenceError: y is not defined</div></pre></td></tr></table></figure>
<p>ES6规定暂时性死区和 <code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明之前就使用这个变量，从而导致意料之外的行为。</p>
<p><strong>暂时性死区的本质：</strong> 只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p><code>let</code> 不允许在相同的作用域内，重复声明同一个变量。（在函数内不能重复声明参数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">function()&#123;</div><div class="line">   let a = 10;</div><div class="line">   var a = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//报错</div><div class="line">function()&#123;</div><div class="line">   let a = 10;</div><div class="line">   let a = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fun(arg)&#123;</div><div class="line">   let arg;    // 报错，不能在函数内重复声明参数</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fun(arg)&#123;</div><div class="line">   &#123;</div><div class="line">       let arg;   //不报错，因为不在同一个作用域内</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在与前面 for 循环的父作用域和子作用域进行对比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 10; i ++)&#123;</div><div class="line">    let i = &quot;abc&quot;;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">// abc</div><div class="line">// abc</div><div class="line">// abc</div></pre></td></tr></table></figure>
<p>这两个变量 <code>i</code> 虽然是在同一次循环当中，但他们的作用域不同，计数器 <code>i</code> 位于父作用域，而循环体内部的变量 <code>i</code> 位于子作用域，所以这里不会报错。<font color="red">（千万不要以为这也是在同一个作用域内重复声明变量）</font></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是学习&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let#let-命令&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰《ECMAScript 6 入门》 let 命令&lt;/a&gt;部分的笔记。&lt;/p&gt;
&lt;h3 id
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6 let" scheme="http://yoursite.com/tags/ES6-let/"/>
    
  </entry>
  
  <entry>
    <title>【转】Web图片加载与渲染时机</title>
    <link href="http://yoursite.com/2017/08/03/%E3%80%90%E8%BD%AC%E3%80%91Web%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA/"/>
    <id>http://yoursite.com/2017/08/03/【转】Web图片加载与渲染时机/</id>
    <published>2017-08-03T13:01:57.000Z</published>
    <updated>2017-08-04T05:27:43.664Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自微信公众号【前端大全】，作者：Leechikit</p>
<p>此文研究页面中的图片资源的加载和渲染时机，使得我们能更好的管理图片资源，避免不必要的流量和提高用户体验。</p>
<h3 id="浏览器的工作流程"><a href="#浏览器的工作流程" class="headerlink" title="浏览器的工作流程"></a>浏览器的工作流程</h3><p>首先了解一下浏览器的工作原理（以 <strong>Webkit引擎</strong> 为例）<br><img src="/img/2017-08-04_001.png" alt="浏览器工作原理"><br>浏览器加载一个HTML页面后进行如下操作：</p>
<ul>
<li>解析HTML —&gt; 构建DOM树</li>
<li>加载样式 —&gt; 解析样式 —&gt; 构建样式规则树</li>
<li>加载javascript —&gt; 执行javascript代码</li>
<li>把DOM树和样式规则树匹配构建渲染树</li>
<li>计算元素位置进行布局</li>
<li>绘制</li>
</ul>
<p>上面无法很直观的判断图片资源什么时候开始加载，下面标出何时加载和渲染图片：</p>
<ul>
<li>解析HTML <strong>【遇到 <code>&lt;img&gt;</code> 标签加载图片】</strong> —&gt; 构建DOM树</li>
<li>加载样式 —&gt; 解析样式 <strong>【遇到背景图片链接不加载】</strong> —&gt; 构建样式规则树</li>
<li>加载javascript —&gt; 执行javascript代码</li>
<li>把DOM树和样式规则树匹配构建渲染树 <strong>【加载渲染树上的背景图片】</strong></li>
<li>计算元素位置进行布局</li>
<li>绘制 <strong>【开始渲染图片】</strong></li>
</ul>
<h3 id="图片加载与渲染规则"><a href="#图片加载与渲染规则" class="headerlink" title="图片加载与渲染规则"></a>图片加载与渲染规则</h3><p>页面中不是所有的 <code>&lt;img&gt;</code> 标签图片和样式表背景图片都会加载。</p>
<h4 id="1、display-none"><a href="#1、display-none" class="headerlink" title="1、display:none"></a>1、display:none</h4><p>a.设置了 <code>display:none</code> 属性的元素，图片不会渲染出来，但会加载；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">.img-purple &#123;</div><div class="line">    background-image: url(../image/purple.png);</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;img src=&quot;../image/pink.png&quot; style=&quot;display:none&quot;&gt;</div><div class="line">&lt;div class=&quot;img-purple&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>把DOM树和样式规则树匹配构建渲染树时，会把可渲染元素上的所有属性（如 <code>display:none</code> 属性和 <code>background-image</code> 属性）结合一起产出到渲染树。 <del>当解析渲染树时会加载 <code>&lt;img&gt;</code> 标签元素上的图片</del> <font color="red">（ <code>&lt;img&gt;</code> 标签元素上的图片是在解析HTML时加载的，而不是在解析渲染树时加载）</font>，发现元素上有 <code>background-image</code> 属性时会加载背景图片。当绘制时发现元素上有 <code>display:none</code> 属性，则不计算该元素位置，也不会绘制该元素。</p>
<p>b.设置了 <code>display:none</code> 属性元素的子元素，样式表中的背景图片不会渲染出来，也不会加载；而 <code>&lt;img&gt;</code> 标签的图片不会渲染出来，但会加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">.img-yellow &#123;</div><div class="line">    background-image: url(../image/yellow.png);</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div style=&quot;display:none&quot;&gt;</div><div class="line">    &lt;img src=&quot;../image/red.png&quot;&gt;</div><div class="line">    &lt;div class=&quot;img-yellow&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>构建渲染树时，只会把可渲染元素产出到渲染树。这就意味有不可渲染元素，当匹配DOM树和样式规则树时，若发现一个元素的属性上有 <code>display:none</code> ，浏览器会认为 <strong>该元素的子元素</strong> 是不可渲染的，因此不会把 <strong>该元素的子元素</strong> 产出到渲染树上。</p>
<p>当解析渲染树时渲染树上没有设置了 <code>display:none</code> 属性元素的子元素，因此不会加载该元素中子元素的背景图片。</p>
<p>当绘制时也因为渲染树上没有设置了 <code>display:none</code> 属性元素的子元素，因此该元素中子元素的背景图片不会渲染出来。</p>
<h4 id="2、重复图片"><a href="#2、重复图片" class="headerlink" title="2、重复图片"></a>2、重复图片</h4><p>页面中多个 <code>&lt;img&gt;</code> 标签或样式表中的背景图片路径是同一个，图片只加载一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">﻿.img-blue &#123;</div><div class="line">    background-image: url(../image/blue.png);</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div class=&quot;img-blue&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;img src=&quot;../image/blue.png&quot;&gt;</div><div class="line">&lt;img src=&quot;../image/blue.png&quot;&gt;</div></pre></td></tr></table></figure>
<p>浏览器请求资源时，都会先判断是否有缓存，若有缓存且未过期则会从缓存中读取，不会再次请求。先加载的图片会存储到浏览器缓存中，后面再次请求同路径图片时会直接读取缓存中的图片。</p>
<h4 id="3、不存在元素的背景图片"><a href="#3、不存在元素的背景图片" class="headerlink" title="3、不存在元素的背景图片"></a>3、不存在元素的背景图片</h4><p>不存在元素的背景图片不会加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.img-blue &#123;</div><div class="line">    background-image: url(../image/blue.png);</div><div class="line">&#125;</div><div class="line">.img-orange&#123;</div><div class="line">    background-image: url(../image/orange.png);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不存在的元素不会产出到DOM树上，因此渲染树上也不会有不存在的元素，当解析渲染树时无法解析不存在的元素，不存在的元素上的图片自然不会加载也不会渲染。</p>
<h4 id="4、伪类的背景图片"><a href="#4、伪类的背景图片" class="headerlink" title="4、伪类的背景图片"></a>4、伪类的背景图片</h4><p>当触发伪类的时候，伪类样式上的背景图片才会加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.img-green &#123;</div><div class="line">    background-image: url(../image/green.png);</div><div class="line">&#125;</div><div class="line">.img-green:hover&#123;</div><div class="line">    background-image: url(../image/red.png);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>触发hover前，DOM树与样式规则树匹配的是无hover状态选择器 <code>.img-green</code> 的样式，因此渲染树上 <code>background-image</code> 属性的值是 <code>url(../image/green.png)</code> ，解析渲染树时加载的是 <em>green.png</em> ，绘制时渲染的也是 <em>green.png</em> 。</p>
<p>触发hover后，因为 <code>.img-green:hover</code> 的优先级比较高，因此DOM树与样式规则树匹配的是有hover状态选择器 <code>.img-green:hover</code> 的样式，渲染树上 <code>background-image</code> 属性的值是 <code>url(../image/red.png)</code> ，解析渲染树时加载的是 <em>red.png</em> ，绘制时渲染的也是 <em>red.png</em> 。</p>
<h3 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h3><h4 id="1、占位图"><a href="#1、占位图" class="headerlink" title="1、占位图"></a>1、占位图</h4><p>当使用样式表中的背景图片作为占位符时，要把背景图片转为 <strong>base64格式</strong> 。这是因为背景图片加载的顺序在标签后面，背景图片可能会在 <code>&lt;img&gt;</code> 标签图片加载完成后才开始加载，达不到想要的效果。</p>
<h4 id="2、预加载"><a href="#2、预加载" class="headerlink" title="2、预加载"></a>2、预加载</h4><p>很多场景里图片是在改变或触发状态后才显示出来的，例如点击一个Tab后，一个设置 <code>display:none</code> 隐藏的父元素变为显示，这个父元素里的子元素图片会在父元素显示后才开始加载；又如当鼠标hover到图标后，改变图标图片，图片会在hover上去后才开始加载，导致出现闪一下这种不友好的体验。</p>
<p>在这种场景下，我们就需要把图片预加载，预加载有很多种方式:</p>
<ul>
<li>若是小图标，可以合并成雪碧图，在改变状态前就把所有图标都一起加载了。</li>
<li>使用上文讲到的，设置了 <code>display:none</code> 属性的元素，图片不会渲染出来，但会加载。把要预加载的图片加到设置了 <code>display:none</code> 的元素背景图或标签里。</li>
<li>在javascript创建 <code>img</code> 对象，把 <code>图片url</code> 设置到 <code>img</code> 对象的 <code>src</code> 属性里。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自微信公众号【前端大全】，作者：Leechikit&lt;/p&gt;
&lt;p&gt;此文研究页面中的图片资源的加载和渲染时机，使得我们能更好的管理图片资源，避免不必要的流量和提高用户体验。&lt;/p&gt;
&lt;h3 id=&quot;浏览器的工作流程&quot;&gt;&lt;a href=&quot;#浏览器的工作流程&quot; class=
    
    </summary>
    
      <category term="图片" scheme="http://yoursite.com/categories/%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="图片加载" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="图片渲染" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Hexo + Github搭建个人博客】——使用Hexo</title>
    <link href="http://yoursite.com/2017/08/03/%E3%80%90Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%91%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Hexo/"/>
    <id>http://yoursite.com/2017/08/03/【Hexo-Github搭建个人博客】——使用Hexo/</id>
    <published>2017-08-03T02:52:11.000Z</published>
    <updated>2017-08-03T09:44:15.543Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇文章<a href="https://maizi93.github.io/2017/08/02/%E3%80%90Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%91%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#more" target="_blank" rel="external">环境搭建</a>中已经介绍过什么是Hexo，这里不再重复，直接进入主题。</p>
<p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo官方使用文档</a></p>
<p>本文中提到的命令行都是使用 <strong>git bash</strong> 来执行。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>确保你的电脑上已经安装了 <strong>Git</strong> 和 <strong>Node.js</strong> （必备），如果没有安装，则参考<a href="https://maizi93.github.io/2017/08/02/%E3%80%90Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%91%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#more" target="_blank" rel="external">环境搭建</a>进行安装；如果已经安装了，接下来只需使用 <strong>npm</strong> 即可完成Hexo的安装。</p>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo</div></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在 Hexo 中有两个主要的配置文件，其名称都是<code>_config.yml</code>。 其中，一个位于站点根目录下，主要包含 Hexo 本身的配置；另一个位于主题目录下，这个配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong> ， 后者称为 <strong>主题配置文件</strong> 。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="创建文件夹，并初始化"><a href="#创建文件夹，并初始化" class="headerlink" title="创建文件夹，并初始化"></a>创建文件夹，并初始化</h4><p>创建一个文件夹，用于放置博客内容，路径自己选择。比如我的是：<code>E:\WEB\hexo</code>（名字可以随便取）。创建好之后，进入该目录。<br><img src="/img/2017-08-03_101.png" alt="进入目录"><br>接着输入以下命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init</div></pre></td></tr></table></figure></p>
<p>hexo会自动下载一些文件到该目录，包括node_modules，目录结构如下图：<br><img src="/img/2017-08-03_102.png" alt="目录结构"></p>
<h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><p>在hexo目录下，执行以下命令，你会发现<code>E:\WEB\hexo</code> 目录下多了好多文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure></p>
<h4 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure>
<p><img src="/img/2017-08-03_104.png" alt="hexo g"><br>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到Github上 <strong>yourusername.github.io</strong> 的仓库上去的。（下图是后期截图，所以public文件夹中包含内容较多）<br><img src="/img/2017-08-03_103.png" alt="pubic文件夹"></p>
<h4 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>以上命令执行后，即可开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 即可看到内容，<code>Ctrl+c</code> 停止本地预览。<br><img src="/img/2017-08-03_105.png" alt="hexo s"></p>
<h4 id="上传到Github"><a href="#上传到Github" class="headerlink" title="上传到Github"></a>上传到Github</h4><p>a.配置站点配置文件<br>打开 <strong>站点配置文件</strong> <code>_config.yml</code> ，找到 <code>deploy</code> 关键字（使用快捷键Ctrl+F更加方便，特别是不知到具体位置的情况下），并进行相关配置。<br><img src="/img/2017-08-03_111.png" alt="配置站点配置文件"><br>b.安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>c.部署博客到Github<br>如果没有安装插件，直接执行命令 <code>hexo d</code> ，将会报错：<strong>ERROR Deployer not found: git</strong><br><img src="/img/2017-08-03_106.png" alt="hexo d"><br>这一过程可能需要等待一下，安装成功后，打开 <a href="http://yourusername.github.io" target="_blank" rel="external">http://yourusername.github.io</a> ，出现与本地预览相同的页面即表示成功部署到Github。<br>这时，进入到你的Github仓库，里面已经有内容了。<br><img src="/img/2017-08-03_112.png" alt="Github仓库"></p>
<p>第一次初始化后，hexo已经自动写了一篇名为Hello World的文章，打开后如下图所示：<br><img src="/img/2017-08-03_107.png" alt="第一次初始化"></p>
<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>是不是觉得上面的默认主题很简陋？那我们就更换一个自己喜欢的主题吧。<br>Hexo官方网站有提供很多不同的主题 <strong><a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo官方主题</a></strong>，找到你喜欢的主题，然后进入该主题的链接，里面一般有文章介绍从哪里获取主题文件，或者直接到Github里面按照<code>hexo+主题关键字</code> 搜索，找到主题关键字之后，<code>git clone</code> 下载到本地；然后将该文件夹复制一份到博客根目录下的<code>themes</code> 文件夹中，最后修改 <code>站点配置文件_config.yml</code> 的theme值为 <code>主题名</code> 即可。<br>本次博客搭建使用的是 <strong>主题NexT</strong> ，该主题的使用方法可以参照<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT官方使用文档</a>，点击<code>开始使用</code> ，跟着一步步做就可以了。 下面记录了本次更换主题的一些操作：</p>
<h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>还是在目录<code>e:/WEB/hexo</code> 下，输入以下命令行，从Github上下载NexT主题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/iissnan/hexo-theme-next theme/next</div></pre></td></tr></table></figure></p>
<h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><p>打开根目录下的 <strong>站点配置文件</strong> <code>_config.yml</code> ，找到 <code>theme</code> 字段，并将其值更改为next。<br><img src="/img/2017-08-03_108.png" alt="启用主题"><br>这样，NexT主题就安装完成了。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，最好使用 <code>hexo clean</code> 来清楚Hexo的缓存，以免出现一些莫名其妙的问题。<br><img src="/img/2017-08-03_109.png" alt="hexo clean"></p>
<h4 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h4><p>先使用 <code>hexo g</code> 重新生成静态文件，再使用 <code>hexo s</code> 开启本地预览，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> ，如果出现的与下图一致，则说明成功更换NexT主题。<br><img src="/img/2017-08-03_110.png" alt="NexT主题"><br>至此，你可以发现根目录下的themes文件夹中多出了一个 <code>next</code> 文件夹，该文件夹中存放的是一些NexT主题相关的文件。<br><img src="/img/2017-08-03_113.png" alt="NexT文件夹"></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="1-选择Scheme"><a href="#1-选择Scheme" class="headerlink" title="1.选择Scheme"></a>1.选择Scheme</h4><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme：</p>
<ul>
<li>Muse  默认Scheme，这是NexT最初的版本</li>
<li>Mist  Muse的紧凑版本</li>
<li>Pisces  双栏Scheme</li>
</ul>
<p>Scheme的切换方法：打开目录：<code>../hexo/themes/next</code> ，找到 <strong>主题配置文件</strong> <code>_config.yml</code>，查找关键字 <code>Scheme</code>，将需要启用的Scheme前面的注释 <code>#</code> 去掉即可。<br><img src="/img/2017-08-03_114.png" alt="Scheme切换"><br>本次博客搭建使用的是Pisces Scheme，下文中的所有配置都是基于该Scheme。</p>
<h4 id="2-博客相关属性"><a href="#2-博客相关属性" class="headerlink" title="2.博客相关属性"></a>2.博客相关属性</h4><p>打开 <strong>站点配置文件</strong> <code>_config.yml</code>，查找关键字 <code>Site</code>，进行相关配置。<br><img src="/img/2017-08-03_115.png" alt="配置站点配置文件"></p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">博客标题</td>
</tr>
<tr>
<td style="text-align:center">subtitle</td>
<td style="text-align:center">博客副标题</td>
</tr>
<tr>
<td style="text-align:center">description</td>
<td style="text-align:center">博客具体描述</td>
</tr>
<tr>
<td style="text-align:center">author</td>
<td style="text-align:center">作者名字</td>
</tr>
<tr>
<td style="text-align:center">language</td>
<td style="text-align:center">博客使用的语言（一般使用简体中文）</td>
</tr>
<tr>
<td style="text-align:center">timezone</td>
<td style="text-align:center">时区。Hexo默认使用你的电脑的时区</td>
</tr>
</tbody>
</table>
<h4 id="3-设置菜单"><a href="#3-设置菜单" class="headerlink" title="3.设置菜单"></a>3.设置菜单</h4><p>请参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">Hexo官方主题</a>，里面写的非常详细。</p>
<h4 id="4-设置侧栏头像"><a href="#4-设置侧栏头像" class="headerlink" title="4.设置侧栏头像"></a>4.设置侧栏头像</h4><p>a.基本操作<br>首先准备好一张图片（你的头像），并将其放置在目录 <code>hexo/themes/next/source/images</code> 下，命名为avatar.png(图片格式任意)；或者你的头像也可以是完整的互联网URI（比如：<a href="http://example.com/avatar.png）" target="_blank" rel="external">http://example.com/avatar.png）</a><br>打开 <strong>主题配置文件</strong> <code>_config.yml</code>，查找 <code>avatar</code> 字段，将其值设置成头像的链接地址。<br><img src="/img/2017-08-03_116.png" alt="设置头像"><br>设置完成后，重新生成静态文件，并部署到Github，你会发现：头像已经换成了你想要的图片，但是它是方形的，不太美观。想必你肯定见过很多头像都是圆形的，甚至还有动画效果，其实也很简单。<br>b.进阶操作——设置圆形可旋转头像<br>在路径<code>..\hexo\themes\next\source\css\_common\components\sidebar</code> 下找到 <strong>siderbar-author.styl</strong>，并将其中的内容全部进行替换即可，替换代码在下面给出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">.site-author-image &#123;</div><div class="line">  display: block;</div><div class="line">  margin: 0 auto;</div><div class="line">  padding: $site-author-image-padding;</div><div class="line">  max-width: $site-author-image-width;</div><div class="line">  height: $site-author-image-height;</div><div class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</div><div class="line"></div><div class="line">  /* 头像圆形 */</div><div class="line">  border-radius: 80px;</div><div class="line">  -webkit-border-radius: 80px;</div><div class="line">  -moz-border-radius: 80px;</div><div class="line">  box-shadow: inset 0 -1px 0 #333sf;</div><div class="line"></div><div class="line">  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束</div><div class="line">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</div><div class="line">  -webkit-animation: play 2s ease-out 1s 1;</div><div class="line">  -moz-animation: play 2s ease-out 1s 1;</div><div class="line">  animation: play 2s ease-out 1s 1;</div><div class="line"></div><div class="line">  /* 鼠标经过头像旋转360度 */</div><div class="line">  -webkit-transition: -webkit-transform 1.5s ease-out;</div><div class="line">  -moz-transition: -moz-transform 1.5s ease-out;</div><div class="line">  transition: transform 1.5s ease-out;</div><div class="line">&#125;</div><div class="line"></div><div class="line">img:hover &#123;</div><div class="line">  /* 鼠标经过停止头像旋转</div><div class="line">  -webkit-animation-play-state:paused;</div><div class="line">  animation-play-state:paused;*/</div><div class="line"></div><div class="line">  /* 鼠标经过头像旋转360度 */</div><div class="line">  -webkit-transform: rotateZ(360deg);</div><div class="line">  -moz-transform: rotateZ(360deg);</div><div class="line">  transform: rotateZ(360deg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Z 轴旋转动画 */</div><div class="line">@-webkit-keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    -webkit-transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    -webkit-transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@-moz-keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    -moz-transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    -moz-transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.site-author-name &#123;</div><div class="line">  margin: $site-author-name-margin;</div><div class="line">  text-align: $site-author-name-align;</div><div class="line">  color: $site-author-name-color;</div><div class="line">  font-weight: $site-author-name-weight;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.site-description &#123;</div><div class="line">  margin-top: $site-description-margin-top;</div><div class="line">  text-align: $site-description-align;</div><div class="line">  font-size: $site-description-font-size;</div><div class="line">  color: $site-description-color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="5-设置favicon图标"><a href="#5-设置favicon图标" class="headerlink" title="5.设置favicon图标"></a>5.设置favicon图标</h4><p>a. 准备好一张常用图片格式的图片作为备选favicon，选择一个favicon制作网站完成icon制作。这里推荐一个免费的在线icon图标制作网站：<a href="http://www.bitbug.net/" target="_blank" rel="external">比特虫</a>。<br>b.icon图标制作完成后，将favicon.ico文件放到目录 <code>../hexo/source</code> 下即可。<br>重新生成静态文件并部署，刷新网页后，就可以看到效果了。<br><img src="/img/2017-08-03_117.png" alt="设置favicon图标"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一篇文章&lt;a href=&quot;https://maizi93.github.io/2017/08/02/%E3%80%90Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%91%E
    
    </summary>
    
      <category term="博客搭建" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>【Hexo + Github搭建个人博客】——环境搭建</title>
    <link href="http://yoursite.com/2017/08/02/%E3%80%90Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%91%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/08/02/【Hexo-Github搭建个人博客】——环境搭建/</id>
    <published>2017-08-02T14:45:51.000Z</published>
    <updated>2017-08-03T02:52:58.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【写在前面】"><a href="#【写在前面】" class="headerlink" title="【写在前面】"></a>【写在前面】</h3><p>写这一系列文章的目的有两个：</p>
<ol>
<li>为了记录Hexo+Github搭建博客的全过程，巩固其中的知识点</li>
<li>跟大家分享一些过程中遇到过的坑，以免再踩（当然还有一些没有解决的，有知道的还请不吝赐教~）</li>
</ol>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>首先，大致了解一下Hexo和Github。</p>
<h4 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h4><p>Github 和 Git 是两回事。<br>Git 是目前世界上最先进的分布式版本控制系统（没有之一）；<br>Github 是在线的基于Git的代码托管服务。<br>参考：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000" target="_blank" rel="external">廖雪峰的官方网站——Git简介</a>，<a href="https://www.baidu.com/s?wd=git%E5%92%8Cgithub%E7%AE%80%E4%BB%8B&amp;rsv_spt=1&amp;rsv_iqid=0xb351df750002e2fe&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;oq=Github%25E7%25AE%2580%25E4%25BB%258B&amp;rsv_t=cc8cXQDXbGqLD2SmPHOfOaSAO3ST6bnjKIIWMtRhLUR%2FOmmJooK6kyHd5BWrVflwnFYh&amp;inputT=763&amp;rsv_pq=e5b12abc000264e8&amp;rsv_sug3=9&amp;rsv_sug1=6&amp;rsv_sug7=100&amp;bs=Github%E7%AE%80%E4%BB%8B" target="_blank" rel="external">git和github简介</a></p>
<h4 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h4><p>官网是这么说的……<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo官网</a><br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>简略地说，使用Hexo+Github搭建博客，就是利用Markdown进行博客的编写，通过Hexo框架解析生成靓丽的静态页面，然后部署到Github上供大家浏览。</p>
<h4 id="使用Hexo-Github搭建博客的好处"><a href="#使用Hexo-Github搭建博客的好处" class="headerlink" title="使用Hexo+Github搭建博客的好处"></a>使用Hexo+Github搭建博客的好处</h4><ul>
<li>免费方便，不需要服务器，不需要后台，无限流量</li>
<li>都是静态文件，访问速度快</li>
<li>数据绝对安全，基于Github的版本管理，可以恢复到任意版本</li>
<li>博客内容可以轻松打包、转义、发布到其他平台</li>
<li>可以随意绑定自己的域名</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在开始搭建博客之前，你必须做好以下准备：</p>
<ul>
<li>安装Git客户端</li>
<li>有Github账号（没有的话，到Github官网申请一个）</li>
<li>安装node.js、npm，并了解相关基础知识</li>
</ul>
<p>本次博客搭建使用的环境：</p>
<ul>
<li>Window7 X64</li>
<li>git版本：2.11.0.windows.1</li>
<li>node.js版本：v6.11.1</li>
<li>vpm版本：3.10.10</li>
<li>Hexo版本：3.3.7</li>
</ul>
<h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>安装Git，创建Github仓库以及相关的一些配置已经在<a href="http://blog.csdn.net/jzooo/article/details/46781805" target="_blank" rel="external">如何向github提交代码？</a>一文中详细给出，这里就不再重复了。</p>
<h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>Node.js的安装过程很简单，一直点击 <strong>Next</strong> ，然后等待安装完成即可。<br><img src="/img/2017-08-02_001.png" alt="Node.js安装"><br><img src="/img/2017-08-02_002.png" alt="Node.js安装"></p>
<h4 id="验证软件的安装"><a href="#验证软件的安装" class="headerlink" title="验证软件的安装"></a>验证软件的安装</h4><p>在“开始”菜单中，输入 <strong>cmd</strong> 后打开 ，输入以下命令行，验证软件是否安装成功，同时还可以检测安装的软件版本。如果结果显示与下图一致，则说明安装成功；否则安装失败，卸载后重新进行安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git --version</div><div class="line">node -v</div><div class="line">npm -v</div></pre></td></tr></table></figure></p>
<p><img src="/img/2017-08-03_001.png" alt="验证安装"></p>
<h3 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h3><h4 id="创建Github仓库"><a href="#创建Github仓库" class="headerlink" title="创建Github仓库"></a>创建Github仓库</h4><p>新建一个与你的用户名相对应的仓库：<strong>yourusername.github.io</strong> ，比如你的用户名是“helloworld”，则新建一个 <strong>helloworld.github.io</strong> 的仓库。（注意：必须是用户名，其他名称无效）<br>以后个人博客的访问地址就是 <strong><a href="http://helloworld.github.io" target="_blank" rel="external">http://helloworld.github.io</a></strong></p>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>本次博客搭建，为了方便，并没有绑定域名，就用默认的 <strong>yourusername.github.io</strong> 来进行访问。如果想要个性化的使用自己的域名，请自行百度，参考他人博客。</p>
<h4 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h4><p>如果你之前已经配置过SSH key，请自动跳过这一步。<br>当然你也可以不配置SSH key，但这样的话，每次博客内容有改动需要提交的时候就需要输入Github账号和密码，不安全。因此，我们对SSH key进行配置，在保证安全性的条件下，解决本地和服务器的链接问题。<br>打开 <strong>git bash</strong>，输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/. ssh</div></pre></td></tr></table></figure></p>
<p>以上命令用于检查本机已存在的ssh密钥，如果提示 <strong>No such file or directory</strong>，则说明你是第一次使用git。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</div></pre></td></tr></table></figure></p>
<p>连续敲三次回车，然后会在用户目录的.ssh文件中生成id_rsa(密钥): ../.ssh/id_rsa，打开并复制里面的内容。进入你的Github的设置页面，点击左侧选项栏中的 <strong>SSH and GPG keys</strong>，再点击 <strong>new SSH key</strong>，把刚才复制的内容粘贴到 <strong>Key</strong> 那一栏， <strong>Title</strong> 栏不需要填写，直接点击 <strong>Add SSH key</strong> 即可。<br><img src="/img/2017-08-03_002.png" alt="在Github中添加SSH key"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>测试是否在Github上成功添加SSH key，如果出现以下提示，在表示添加成功。<br><img src="/img/2017-08-03_003.png" alt="测试是否成功"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【写在前面】&quot;&gt;&lt;a href=&quot;#【写在前面】&quot; class=&quot;headerlink&quot; title=&quot;【写在前面】&quot;&gt;&lt;/a&gt;【写在前面】&lt;/h3&gt;&lt;p&gt;写这一系列文章的目的有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了记录Hexo+Github搭建博客的全过程，巩固
    
    </summary>
    
      <category term="博客搭建" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>word转pdf时存在的一些问题</title>
    <link href="http://yoursite.com/2017/07/19/word%E8%BD%ACpdf%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/07/19/word转pdf时存在的一些问题/</id>
    <published>2017-07-19T08:44:49.000Z</published>
    <updated>2017-07-19T09:17:07.140Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>MATLAB图片中的网格线会变成实线（其实也只是看起来是实线，本质上还是虚线，把图片放大就会有所发现）</p>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>首先默认电脑上安装了Adobe Acrobat XI Pro  <img src="/img/2017-07-19_401.png" alt="Adobe Acrobat XI Pro"><br>1.在word中打开要转成pdf的文档，点击  <strong>文件</strong>  ————  <strong>打印</strong> ，然后选择打印机名称: Adobe PDF（这是个虚拟打印机）<br><img src="/img/2017-07-19_402.png" alt=""><br>2.选择后，点击右边的  <strong>属性</strong>  按钮，进入Adobe PDF文档属性设置页面，将默认设置修改为高质量打印<br><img src="/img/2017-07-19_403.png" alt=""><br>3.然后点击右侧的  <strong>编辑</strong>  按钮，在左边侧栏中点击  <strong>图像</strong>  ，进行设置：在彩色图像区域，将缩减像素采样关闭，图像质量选择“最高”，右侧的像素根据需要设置。完成以上步骤后，点击最下方的  <strong>确认</strong>  按钮，这个时候会弹出一个框让你保存刚刚设置的打印方案，记住这个文件名，点击  <strong>保存</strong>  即可。<br><img src="/img/2017-07-19_404.png" alt=""><br><img src="/img/2017-07-19_405.png" alt=""><br>4.回到Adobe PDF文档属性设置页面，选择默认设置为刚才保存的文件明后，点击右下角的  <strong>确认</strong>  即可<br><img src="/img/2017-07-19_406.png" alt=""><br>5.最后，回到打印页面，点击  <strong>确认</strong> 按钮，就可以生成PDF文档，并根据需要保存文件夹</p>
<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>在EDAs上传PDF文档，经常会出现格式有问题，上传不成功的现象，这个主要是PDF文档字体嵌入的问题。</p>
<h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p>1.打开生成的PDF文档，点击  <strong>文件</strong>  ————  <strong>文档属性</strong>  ————  <strong>字体</strong>：右边显示的字体中，有的字体后面括号内写了  <strong>（嵌入字符集）</strong>，有的没有，这就是上传不成功的原因。<br><img src="/img/2017-07-19_407.png" alt=""><br>2.重新回到Adobe PDF文档属性设置页面，点击  <strong>字体</strong>， 把右侧  <strong>从不嵌入</strong>  框中的全部删除，点击  <strong>另存为</strong>  按钮，按问题一种所说的步骤继续完成即可。<br><img src="/img/2017-07-19_408.png" alt=""><br>这样设置后，转成的PDF文档中的字体就全部都是（嵌入字符集），不会出现上传不成功的问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题一&quot;&gt;&lt;a href=&quot;#问题一&quot; class=&quot;headerlink&quot; title=&quot;问题一&quot;&gt;&lt;/a&gt;问题一&lt;/h4&gt;&lt;h5 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描
    
    </summary>
    
      <category term="office" scheme="http://yoursite.com/categories/office/"/>
    
    
      <category term="word" scheme="http://yoursite.com/tags/word/"/>
    
      <category term="pdf" scheme="http://yoursite.com/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>单选框和复选框</title>
    <link href="http://yoursite.com/2017/07/19/%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86/"/>
    <id>http://yoursite.com/2017/07/19/单选框和复选框/</id>
    <published>2017-07-19T08:24:25.000Z</published>
    <updated>2017-07-19T08:41:07.854Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单选框以及复选框的使用"><a href="#单选框以及复选框的使用" class="headerlink" title="单选框以及复选框的使用"></a>单选框以及复选框的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;  </div><div class="line">&lt;html&gt;  </div><div class="line">&lt;head&gt;  </div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;  </div><div class="line">    &lt;title&gt;单选框以及复选框的使用&lt;/title&gt;  </div><div class="line">&lt;/head&gt;  </div><div class="line"></div><div class="line">&lt;body&gt;  </div><div class="line">    &lt;form&gt;  </div><div class="line">        &lt;!--单选框--&gt;  </div><div class="line">        &lt;label&gt;性别：&lt;/label&gt;  </div><div class="line">        &lt;label&gt;男&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;man&quot; /&gt;  </div><div class="line">        &lt;label&gt;女&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;woman&quot; checked=&quot;checked&quot;/&gt;    &lt;!--默认选中--&gt;  </div><div class="line">        &lt;br/&gt;&lt;br/&gt;  </div><div class="line"></div><div class="line">        &lt;!--复选框--&gt;  </div><div class="line">        &lt;label&gt;爱好：&lt;/label&gt;  </div><div class="line">        &lt;label&gt;篮球&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot; /&gt;  </div><div class="line">        &lt;label&gt;足球&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot; /&gt;  </div><div class="line">        &lt;label&gt;跑步&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot; checked=&quot;checked&quot; /&gt;     &lt;!--默认选中--&gt;  </div><div class="line">        &lt;label&gt;跳舞&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;4&quot; /&gt;  </div><div class="line">    &lt;/form&gt;  </div><div class="line">&lt;/body&gt;  </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h5 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h5><ul>
<li>radio：表示单选框</li>
<li>checkbox：表示多选框</li>
</ul>
<h5 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h5><p>提交数据到服务器的值（供后端程序使用）</p>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>为控件命名，以备后台程序ASP、PHP使用</p>
<h5 id="checked属性"><a href="#checked属性" class="headerlink" title="checked属性"></a>checked属性</h5><p>当设置checked=”checked”时，该选项被默认选中</p>
<p>结果显示如下图：<br><img src="/img/2017-07-19_301.png" alt="结果显示图"><br>以上代码只有在点击选项后面的圆圈或者小方块的时候才能选中该选项，那么如何实现点击文字就选中选项呢？</p>
<h4 id="点击文字选中选项"><a href="#点击文字选中选项" class="headerlink" title="点击文字选中选项"></a>点击文字选中选项</h4><p>一般有两种实现方法，具体代码分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;  </div><div class="line">&lt;html&gt;  </div><div class="line">&lt;head&gt;  </div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;  </div><div class="line">    &lt;title&gt;如何实现点击文字选中选项&lt;/title&gt;  </div><div class="line">&lt;/head&gt;  </div><div class="line"></div><div class="line">&lt;body&gt;  </div><div class="line">    &lt;form&gt;  </div><div class="line">        &lt;!--第一种方法：把文字和input包含在lable标签中--&gt;  </div><div class="line">        &lt;!--单选框--&gt;  </div><div class="line">        &lt;label&gt;性别：&lt;/label&gt;  </div><div class="line">        &lt;label&gt;男&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;man&quot; /&gt;&lt;/label&gt;  </div><div class="line">        &lt;label&gt;女&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;woman&quot; checked=&quot;checked&quot;/&gt;&lt;/label&gt;      &lt;!--默认选中--&gt;  </div><div class="line">        &lt;br/&gt;&lt;br/&gt;  </div><div class="line">        &lt;!--复选框--&gt;  </div><div class="line">        &lt;label&gt;爱好：&lt;/label&gt;  </div><div class="line">        &lt;label&gt;篮球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot; /&gt;&lt;/label&gt;  </div><div class="line">        &lt;label&gt;足球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot; /&gt;&lt;/label&gt;  </div><div class="line">        &lt;label&gt;跑步&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot; checked=&quot;checked&quot; /&gt; &lt;/label&gt;     &lt;!--默认选中--&gt;  </div><div class="line">        &lt;label&gt;跳舞&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;4&quot; /&gt;&lt;/label&gt;  </div><div class="line"></div><div class="line">        &lt;!--第二种方法：文字在label标签内,input中的id和&lt;label&gt;标签内的for=&quot;&quot;中的名字必须相同--&gt;  </div><div class="line">        &lt;!--单选框--&gt;  </div><div class="line">        &lt;label&gt;性别：&lt;/label&gt;  </div><div class="line">        &lt;label for=&quot;radio1&quot;&gt;男&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;man&quot; id=&quot;radio1&quot; /&gt;  </div><div class="line">        &lt;label for=&quot;radio2&quot;&gt;女&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;woman&quot; id=&quot;radio2&quot; checked=&quot;checked&quot;/&gt;    &lt;!--默认选中--&gt;  </div><div class="line">        &lt;br/&gt;&lt;br/&gt;  </div><div class="line">        &lt;!--复选框--&gt;  </div><div class="line">        &lt;label&gt;爱好：&lt;/label&gt;  </div><div class="line">        &lt;label for=&quot;check1&quot;&gt;篮球&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot; id=&quot;check1&quot; /&gt;  </div><div class="line">        &lt;label for=&quot;check2&quot;&gt;足球&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot; id=&quot;check2&quot; /&gt;  </div><div class="line">        &lt;label for=&quot;check3&quot;&gt;跑步&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot; id=&quot;check3&quot; checked=&quot;checked&quot; /&gt;     &lt;!--默认选中--&gt;  </div><div class="line">        &lt;label for=&quot;check4&quot;&gt;跳舞&lt;/label&gt;  </div><div class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;4&quot; id=&quot;check4&quot; /&gt;  </div><div class="line">    &lt;/form&gt;  </div><div class="line">&lt;/body&gt;  </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;单选框以及复选框的使用&quot;&gt;&lt;a href=&quot;#单选框以及复选框的使用&quot; class=&quot;headerlink&quot; title=&quot;单选框以及复选框的使用&quot;&gt;&lt;/a&gt;单选框以及复选框的使用&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="表单" scheme="http://yoursite.com/tags/%E8%A1%A8%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>WampServer的安装和配置</title>
    <link href="http://yoursite.com/2017/07/19/Wampserver%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/07/19/Wampserver的安装和配置/</id>
    <published>2017-07-19T07:43:24.000Z</published>
    <updated>2017-07-19T08:18:42.846Z</updated>
    
    <content type="html"><![CDATA[<h4 id="WampServer介绍"><a href="#WampServer介绍" class="headerlink" title="WampServer介绍"></a>WampServer介绍</h4><p>首先解读一下Wamp这四个字母分别代表什么：</p>
<ul>
<li>w: Windows</li>
<li>a: Apache</li>
<li>m: Mysql</li>
<li>p: PHP<br>Wamp就是WindowsApacheMyqlPHP集成安装环境，即在windows下的apache、php和mysql的服务器软件；而WampServer呢就是Apache Web服务器、PHP解释器以及MySQL数据库的整合软件包。这样一来，开发人员就不必花大量时间在繁琐的环境配置中，可腾出更多精力去做开发。<h5 id="WampServer的特点"><a href="#WampServer的特点" class="headerlink" title="WampServer的特点"></a>WampServer的特点</h5>1.支持中文，一键安装，省时省力，任何人都可以轻松搭建；<br>2.集成Apache/MySQL/PHP/PhpMyadmin；支持PHP扩展，Apache的mod_rewrite；<br>3.一键启动、重启、停止所有服务，一键切换到离线状态等等。</li>
</ul>
<h4 id="WampServer的安装和配置"><a href="#WampServer的安装和配置" class="headerlink" title="WampServer的安装和配置"></a>WampServer的安装和配置</h4><p>本文中记录了我在安装使用WampServer过程中遇到的一些问题，在网上查阅了很多资料，在这里稍作整理。（主要针对Window7）</p>
<h5 id="WampServer的安装"><a href="#WampServer的安装" class="headerlink" title="WampServer的安装"></a>WampServer的安装</h5><p>自行百度进行安装，根据自己的电脑选择合适的版本（x86/x64）；安装过程很简单，基本就是直接点击下一步去就可以，有两点需要注意一下：<br>1.选择默认浏览工具，默认为explorer.exe，直接点击打开杰克，如下图所示：<br><img src="/img/2017-07-19_201.jpg" alt="默认浏览工具"><br>2.输入管理员邮箱以及邮箱SMTP的服务器（这个窗口有的版本会出现，有的不会出现），如果你愿意填写就写一下，一般直接点击next也不会影响安装。</p>
<h5 id="安装结束，打开WampServer"><a href="#安装结束，打开WampServer" class="headerlink" title="安装结束，打开WampServer"></a>安装结束，打开WampServer</h5><p>1.打开WampServer时需要注意的是，尽量把电脑上的浏览器和一些媒体播放器先关闭，以免占用 <strong>80端口</strong>；<br>2.在保证80端口没有被占用的情况下打开WampServer，可能会出现提示窗口： <strong>提示MSVCR110.dll丢失</strong>；<br>解决办法：首先卸载已经安装好的WampServer，对于 <strong>32位</strong> 的系统，安装 <strong>vcredist_x86.exe</strong> 之后，重新安装Wampserver；而对于 <strong>64位</strong> 的系统，则安装 <strong>vcredist_x64.exe</strong>，再重新安装Wampserver即可。<br><strong>vcredist_x86.exe</strong> 和 <strong>vcredist_x64.exe</strong> 的下载地址：<a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=30679" target="_blank" rel="external">http://www.microsoft.com/zh-cn/download/details.aspx?id=30679</a></p>
<h5 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h5><p>安装完并成功启动后，突变显示为绿色，右击突变，然后依次选择 <strong>Language</strong> —— <strong>chinese</strong> 进行语言设置；</p>
<h5 id="访问WampServer页面"><a href="#访问WampServer页面" class="headerlink" title="访问WampServer页面"></a>访问WampServer页面</h5><p>鼠标左键点击绿色图标，再点击 <strong>localhost</strong> 即可访问该页面，默认为 <strong>Server Configuration</strong><br><img src="/img/2017-07-19_202.jpg" alt=""><br><img src="/img/2017-07-19_203.jpg" alt="Server Configuration页面"></p>
<h5 id="进入phpmyadmin管理页面"><a href="#进入phpmyadmin管理页面" class="headerlink" title="进入phpmyadmin管理页面"></a>进入phpmyadmin管理页面</h5><p>点击Tools下的phpmyadmin，即可进入phpmyadmin管理页面，首先会出现一个登陆页面，一般用户名为root，密码为空，点击右下角的执行即可进入。<br><img src="/img/2017-07-19_204.jpg" alt="进入phpmyadmin管理页面"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;WampServer介绍&quot;&gt;&lt;a href=&quot;#WampServer介绍&quot; class=&quot;headerlink&quot; title=&quot;WampServer介绍&quot;&gt;&lt;/a&gt;WampServer介绍&lt;/h4&gt;&lt;p&gt;首先解读一下Wamp这四个字母分别代表什么：&lt;/p&gt;
&lt;ul
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="集成环境" scheme="http://yoursite.com/tags/%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>关于MATLAB画图</title>
    <link href="http://yoursite.com/2017/07/19/%E5%85%B3%E4%BA%8EMATLAB%E7%94%BB%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/07/19/关于MATLAB画图/</id>
    <published>2017-07-19T07:16:22.000Z</published>
    <updated>2017-07-19T07:30:36.166Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设置基本线型和颜色"><a href="#设置基本线型和颜色" class="headerlink" title="设置基本线型和颜色"></a>设置基本线型和颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x=0:0.1:2;</div><div class="line">y=2*x.^2-x;</div><div class="line">plot(x,y);</div></pre></td></tr></table></figure>
<p>以上MATLAB代码画的是曲线: y=2x^2-x<br><img src="/img/2017-07-19_101.jpg" alt="曲线图"></p>
<h5 id="设置线型"><a href="#设置线型" class="headerlink" title="设置线型"></a>设置线型</h5><ul>
<li>plot(x,y,’–’);                 // 画虚线</li>
<li>plot(x,y,’.’);                  // 画点</li>
<li>plot(x,y,’:’);                  // 画点线</li>
<li>plot(x,y,’o’);                  // 画圆圈</li>
<li>plot(x,y,’+’);                  // 画加号</li>
<li>plot(x,y,’x’);                  // 画叉</li>
<li>plot(x,y,’p’);                  // 画星号（空心五角星）</li>
<li>plot(x,y,’d’);                  // 画菱形</li>
<li>plot(x,y,’s’);                  // 画方块</li>
<li>plot(x,y,’*‘);                 // 画星号（*）</li>
<li>plot(x,y,’-‘);                  // 画实线</li>
<li>plot(x,y,’-.’);                 // 画点划线</li>
<li>……<br>以上列举了常用的一些线型，这些线型中部分还可以组合使用，就像最后一个点划线一样。</li>
</ul>
<h5 id="设置颜色（八种基本颜色）"><a href="#设置颜色（八种基本颜色）" class="headerlink" title="设置颜色（八种基本颜色）"></a>设置颜色（八种基本颜色）</h5><ul>
<li>plot(x,y,’r’);                   // 红色</li>
<li>plot(x,y,’b’);                   // 蓝色</li>
<li>plot(x,y,’g’);                   // 绿色</li>
<li>plot(x,y,’y’);                   // 黄色</li>
<li>plot(x,y,’m’);                   // 紫红色</li>
<li>plot(x,y,’c’);                   // 蓝绿色</li>
<li>plot(x,y,’w’);                   // 白色</li>
<li>plot(x,y,’k’);                   // 黑色</li>
</ul>
<h5 id="设置线条粗细"><a href="#设置线条粗细" class="headerlink" title="设置线条粗细"></a>设置线条粗细</h5><ul>
<li>plot(x,y,’linewidth’,3);</li>
</ul>
<p>类似的，还有标记点的边缘颜色（MarkerEdgeColor）、填充颜色（MarkerFaceColor）以及标记点的大小（MarkerSize）。</p>
<h4 id="画平滑曲线"><a href="#画平滑曲线" class="headerlink" title="画平滑曲线"></a>画平滑曲线</h4><p>1.通过拟合来画平滑曲线<br>2.通过插值来画平滑曲线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">clear all;clc;  </div><div class="line">a=1:1:10;                                  % 横坐标   b=[2 4 8 10 16 20 30 36 50 80];            % 纵坐标   plot(a,b,&apos;b&apos;);                             % 直接画图  </div><div class="line">hold on; grid on;     </div><div class="line"></div><div class="line">%%%% 第一种，画平滑曲线的画法  </div><div class="line">c=polyfit(a,b,2);                           % 进行拟合，c为2次拟合后的系数  </div><div class="line">d=polyval(c,a,1);                           % 拟合后，每一个横坐标对应的值即为d   </div><div class="line">plot(a, d, &apos;r&apos;);                            % 拟合后的曲线   plot(a, b, &apos;*&apos;);                            % 将每个点 用*画出来     </div><div class="line"></div><div class="line">%%%% 第二种，画平滑曲线的方法   values = spcrv([[a(1) a a(end)];[b(1) b b(end)]],3);   plot(values(1,:),values(2,:), &apos;g&apos;);</div></pre></td></tr></table></figure></p>
<p><img src="/img/2017-07-19_102.jpg" alt="平滑曲线图"></p>
<h4 id="根据大量离散点画出包络曲线（比如在画功率谱的时候）"><a href="#根据大量离散点画出包络曲线（比如在画功率谱的时候）" class="headerlink" title="根据大量离散点画出包络曲线（比如在画功率谱的时候）"></a>根据大量离散点画出包络曲线（比如在画功率谱的时候）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// reshape函数即将矩阵PSD重新调整为d行N/D列的新矩阵  </div><div class="line">y=reshape(PSD,d,N/d);          // PSD表示纵坐标，N表示采的点数，d表示每段的距离  </div><div class="line">y=max(y);  </div><div class="line">x=linspace(0,max(f),N/d);      // f表示横坐标  </div><div class="line">// linspace()函数用于产生0，max(f)之间N/d个元素组成的一维数组</div></pre></td></tr></table></figure>
<p><img src="/img/2017-07-19_103.jpg" alt="平滑曲线图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;设置基本线型和颜色&quot;&gt;&lt;a href=&quot;#设置基本线型和颜色&quot; class=&quot;headerlink&quot; title=&quot;设置基本线型和颜色&quot;&gt;&lt;/a&gt;设置基本线型和颜色&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
    
    </summary>
    
      <category term="MATLAB" scheme="http://yoursite.com/categories/MATLAB/"/>
    
    
      <category term="画图" scheme="http://yoursite.com/tags/%E7%94%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://yoursite.com/2017/07/19/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2017/07/19/三次握手和四次挥手/</id>
    <published>2017-07-19T06:48:31.000Z</published>
    <updated>2017-07-19T07:13:22.641Z</updated>
    
    <content type="html"><![CDATA[<p>之前在<a href="https://maizi93.github.io/2017/07/19/从地址栏输入URL到页面加载完成，发生了什么？/" target="_blank" rel="external">从地址栏输入URL到页面加载完成，发生了什么？</a>一文中提到了 <strong>三次握手</strong> 和 <strong>四次挥手</strong> ，本文将具体展开。</p>
<h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><ul>
<li>三次握手</li>
<li>四次挥手</li>
</ul>
<h5 id="图形解析"><a href="#图形解析" class="headerlink" title="图形解析"></a>图形解析</h5><p>话不多说，直接上图<br><img src="/img/2017-07-19_001.jpg" alt="三次握手和四次挥手"></p>
<h5 id="符号解释"><a href="#符号解释" class="headerlink" title="符号解释"></a>符号解释</h5><ul>
<li>SYN：表示发起一个新的连接；（标志位）</li>
<li>Seq序号：用来标识从TCP源端向目的端发送的字节流，发送方发送数据时对此进行过标记；</li>
<li>ACK：确认序号有效，ACK = Seq + 1；（标志位）</li>
<li>FIN：表示释放一个连接；（标志位）</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li>第一次握手<br>客户端（Client）发送SYN = 1， 随机产生Seq = X，将数据包发送给服务器（Server），并进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手<br>服务器接收到数据包后，由SYN = 1知道客户端请求建立连接，服务器将SYN和ACK都置为1，ack = X + 1，随机产生Seq = Y，将数据包放给客户端以确认连接请求，服务器进入SYN_RCVD状态；</li>
<li>第三次握手<br>客户端收到确认后，检查ACK = 1？ack = X + 1？如果是，则将ACK置为1，ack = Y + 1, Seq = X + 1，并将数据包发送给服务器。服务器接收到数据包后，确认ACK = 1？ack = Y + 1？如果是，则连接建立成功，客户端和服务器端都进入ESTABLISHED状态，也即完成了三次握手。</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>（由于TCP连接是全双工的，需要对每个方向单独进行关闭，也即需要客户端和服务器端分别发送FIN来关闭连接。首先进行关闭的一方将执行主动关闭，另一方将执行被动关闭。客户端和服务器端都可以是主动关闭的那一方）。</p>
<ul>
<li>第一次挥手<br>客户端发送FIN = 1（为了简便，图中其余标志位和符号在这里省略，和三次握手的原理是一样的），用来关闭客户端到服务器端的数据传达，客户端进入FIN-WAIT-1状态；</li>
<li>第二次挥手<br>服务器接收到数据包后，由FIN = 1知道客户端请求断开连接，将ACK置为1，ack = X + 1，服务器端进入CLOSE-WAIT状态（注意：这里服务器但还是可以正常发送数据，只是客户端不再发送数据）；客户端收到确认后，检查ACK和ack，如果正确，则进入FIN-WAIT-2状态；</li>
<li>第三次挥手<br>服务器端发送FIN = 1，用来关闭服务器端到客户端的数据传送，进入LAST-ACK状态；</li>
<li>第四次挥手<br>客户端接收到数据包后，进入TIME-WAIT状态，然后发送数据包（ACK = 1，ack = Z + 1）给服务器，服务器进入CLOSED状态，即完成四次挥手。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在&lt;a href=&quot;https://maizi93.github.io/2017/07/19/从地址栏输入URL到页面加载完成，发生了什么？/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从地址栏输入URL到页面加载完成，发生了什么？&lt;/a&gt;一文中提
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP连接" scheme="http://yoursite.com/tags/TCP%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>从地址栏输入URL到页面加载完成，发生了什么？</title>
    <link href="http://yoursite.com/2017/07/19/%E4%BB%8E%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/07/19/从地址栏输入URL到页面加载完成，发生了什么？/</id>
    <published>2017-07-19T06:37:09.000Z</published>
    <updated>2017-07-19T06:45:13.161Z</updated>
    
    <content type="html"><![CDATA[<h4 id="从地址栏输入URL到页面加载完成，发生了什么？"><a href="#从地址栏输入URL到页面加载完成，发生了什么？" class="headerlink" title="从地址栏输入URL到页面加载完成，发生了什么？"></a>从地址栏输入URL到页面加载完成，发生了什么？</h4><p>参考别人的文章后，自己总结的，有写的不妥的，还请大家指正。</p>
<p>整个过程大致分为以下几个步骤：<br>1.浏览器查看缓存，如果缓存中有，则直接在屏幕中显示内容；若没有，则执行以下步骤；<br>2.进行域名（DNS）解析，获取相应的IP地址；（域名解析的过程，实际上就是将域名还原为IP地址的过程）<br>3.浏览器向服务器发起TCP链接，与浏览器建立TCP三次握手；<br>4.握手成功后，浏览器发送HTTP请求；（HTTP请求主要包括：请求行、请求头、请求正文）<br>5.服务器接收并处理请求，并返回HTTP响应；<br>6.浏览器收到HTTP响应后，开始构建页面，解析html源码，对页面进行渲染；<br>7.生成DOM树，解析CSS样式、js交互；<br>8.（可选）浏览器发送静态资源请求；<br>9.（可选）浏览器发送Ajax请求；<br>10.页面构建完成，关闭连接。（TCP四次挥手）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;从地址栏输入URL到页面加载完成，发生了什么？&quot;&gt;&lt;a href=&quot;#从地址栏输入URL到页面加载完成，发生了什么？&quot; class=&quot;headerlink&quot; title=&quot;从地址栏输入URL到页面加载完成，发生了什么？&quot;&gt;&lt;/a&gt;从地址栏输入URL到页面加载完成，
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="页面加载" scheme="http://yoursite.com/tags/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>表格排序-JavaScript</title>
    <link href="http://yoursite.com/2017/07/19/%E8%A1%A8%E6%A0%BC%E6%8E%92%E5%BA%8F-JavaScript/"/>
    <id>http://yoursite.com/2017/07/19/表格排序-JavaScript/</id>
    <published>2017-07-19T03:50:45.000Z</published>
    <updated>2017-07-19T10:02:08.107Z</updated>
    
    <content type="html"><![CDATA[<p>笔试做到一个表格排序的题，当时没有完全实现，本文记录了用JavavScript进行表格排序的实现过程。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>在页面上有如下表格，当点击成绩的时候，所有行数据根据成绩从低到高排序，再点击时成绩则变为从高到低排序。</p>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:left">性别</th>
<th style="text-align:left">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">张三</td>
<td style="text-align:left">男</td>
<td style="text-align:left">77</td>
</tr>
<tr>
<td style="text-align:left">李四</td>
<td style="text-align:left">女</td>
<td style="text-align:left">87</td>
</tr>
<tr>
<td style="text-align:left">王五</td>
<td style="text-align:left">未知</td>
<td style="text-align:left">50</td>
</tr>
</tbody>
</table>
<p>第一次点击成绩之后：</p>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:left">性别</th>
<th style="text-align:left">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">王五</td>
<td style="text-align:left">未知</td>
<td style="text-align:left">50</td>
</tr>
<tr>
<td style="text-align:left">张三</td>
<td style="text-align:left">男</td>
<td style="text-align:left">77</td>
</tr>
<tr>
<td style="text-align:left">李四</td>
<td style="text-align:left">女</td>
<td style="text-align:left">87</td>
</tr>
</tbody>
</table>
<p>再次点击成绩之后：</p>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:left">性别</th>
<th style="text-align:left">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">李四</td>
<td style="text-align:left">女</td>
<td style="text-align:left">87</td>
</tr>
<tr>
<td style="text-align:left">张三</td>
<td style="text-align:left">男</td>
<td style="text-align:left">77</td>
</tr>
<tr>
<td style="text-align:left">王五</td>
<td style="text-align:left">未知</td>
<td style="text-align:left">50</td>
</tr>
</tbody>
</table>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><h5 id="html代码部分"><a href="#html代码部分" class="headerlink" title="html代码部分"></a>html代码部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">    &lt;thead&gt;</div><div class="line">        &lt;tr&gt;  </div><div class="line">            &lt;td&gt;姓名&lt;/td&gt;  </div><div class="line">            &lt;td&gt;性别&lt;/td&gt;  </div><div class="line">            &lt;td&gt;成绩&lt;/td&gt;  </div><div class="line">        &lt;/tr&gt;  </div><div class="line">    &lt;/thead&gt;</div><div class="line">    &lt;tbody&gt;</div><div class="line">        &lt;tr&gt;  </div><div class="line">            &lt;td&gt;张三&lt;/td&gt;  </div><div class="line">            &lt;td&gt;男&lt;/td&gt;  </div><div class="line">            &lt;td&gt;77&lt;/td&gt;  </div><div class="line">        &lt;/tr&gt;  </div><div class="line">        &lt;tr&gt;  </div><div class="line">            &lt;td&gt;李四&lt;/td&gt;  </div><div class="line">            &lt;td&gt;女&lt;/td&gt;  </div><div class="line">            &lt;td&gt;87&lt;/td&gt;  </div><div class="line">        &lt;/tr&gt;  </div><div class="line">        &lt;tr&gt;  </div><div class="line">            &lt;td&gt;王五&lt;/td&gt;  </div><div class="line">            &lt;td&gt;未知&lt;/td&gt;  </div><div class="line">            &lt;td&gt;50&lt;/td&gt;  </div><div class="line">        &lt;/tr&gt;  </div><div class="line">    &lt;/tbody&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure>
<h5 id="CSS代码部分"><a href="#CSS代码部分" class="headerlink" title="CSS代码部分"></a>CSS代码部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">*&#123;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0;</div><div class="line">&#125;</div><div class="line">table&#123;</div><div class="line">    border: solid 1px;</div><div class="line">    margin: 60px auto;</div><div class="line">    width: 600px;</div><div class="line">    border-collapse: collapse;    /*为表格设置合并边框模型*/</div><div class="line">    cursor: default;    </div><div class="line">    /*该属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状，default默认光标(通常是一个箭头)*/</div><div class="line">&#125;</div><div class="line">tr&#123;</div><div class="line">    border: solid 1px;</div><div class="line">    height: 26px;</div><div class="line">&#125;</div><div class="line">thead&#123;</div><div class="line">  border: solid 1px;</div><div class="line">  cursor: pointer;</div><div class="line">  /*光标呈现为指示链接的指针(一只手)*/</div><div class="line">&#125;</div><div class="line">td&#123;</div><div class="line">  border: solid 1px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="JavaScript代码部分"><a href="#JavaScript代码部分" class="headerlink" title="JavaScript代码部分"></a>JavaScript代码部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">&lt;script type = &quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function()&#123;</div><div class="line">        var tHead = document.getElementsByTagName(&apos;thead&apos;)[0];</div><div class="line">        var tBody = document.getElementsByTagName(&apos;tbody&apos;)[0];</div><div class="line">        var tHeadTd = tHead.getElementsByTagName(&apos;td&apos;);</div><div class="line">        var rlen = tBody.rows.length;    // 获取tbody中的行数</div><div class="line">        var clen = tBody.rows[0].cells.length;   // 获取tbody中的每行的列数</div><div class="line"></div><div class="line">        var arr = [];</div><div class="line">        for(var  i = 0; i &lt; rlen; i ++)&#123;</div><div class="line">          arr[i] = tBody.rows[i];    // 把tBody中的内容以行的形式放到数组arr中</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        var count= 0;    // 记录点击的次数（第一次点击，升序排列；再次点击，降序排列）</div><div class="line">        // 当点击“成绩”单元格时</div><div class="line">        tHeadTd[2].onclick = function()&#123;</div><div class="line">            if(count == 0)&#123;</div><div class="line">              sortUp(arr,2);</div><div class="line">              count = 1;</div><div class="line">            &#125;else&#123;</div><div class="line">              sortDown(arr,2);</div><div class="line">              count = 0;</div><div class="line">            &#125;</div><div class="line">            var str = &quot;&quot;;</div><div class="line">            var html = &quot;&quot;;</div><div class="line"></div><div class="line">            // 遍历数组arr的每一行</div><div class="line">            for(var j = 0; j &lt; arr.length; j ++)&#123;</div><div class="line">                // 遍历数组arr每一行的长度</div><div class="line">                for(var k = 0; k &lt; clen; k ++)&#123;</div><div class="line">                    // 获取排序后每行每个单元格的内容</div><div class="line">                    str += &quot;&lt;td&gt;&quot; + arr[j].children[k].innerText + &quot;&lt;/td&gt;&quot;;</div><div class="line">                &#125;</div><div class="line">                // 把每个单元格放到行内，并把每行&lt;tr&gt;赋给html</div><div class="line">                html = &quot;&lt;tr&gt;&quot; + str + &quot;&lt;/tr&gt;&quot;;</div><div class="line">                str = &quot;&quot;;</div><div class="line">            &#125;</div><div class="line">            tBody.innerHTML = html;     // 把html内容添加到表格tbody中</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 数字升序</div><div class="line">        function sortUp(arr,n)&#123;</div><div class="line">            arr.sort(function(a,b)&#123;</div><div class="line">                return a.children[n].innerText - b.children[n].innerText;  </div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 数字降序</div><div class="line">        function sortDown(arr,n)&#123;</div><div class="line">            arr.sort(function(a,b)&#123;</div><div class="line">                return b.children[n].innerText - a.children[n].innerText;  </div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔试做到一个表格排序的题，当时没有完全实现，本文记录了用JavavScript进行表格排序的实现过程。&lt;/p&gt;
&lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;在页面上有如下表格，当
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="表格排序" scheme="http://yoursite.com/tags/%E8%A1%A8%E6%A0%BC%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
